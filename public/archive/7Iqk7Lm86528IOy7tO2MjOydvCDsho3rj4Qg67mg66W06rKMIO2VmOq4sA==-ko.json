{"content":"<body>\n<p>안녕하세요. 스튜디오 킹덤에서 쿠키런: 킹덤 서버 개발자 전윤재입니다. 본 글에서는 스칼라로 개발된 쿠키런: 킹덤 서버의 빌드 속도 개선 경험을 공유합니다.</p>\n\n<h2>1. Typeclass 인스턴스 정의 위치 최적화</h2>\n<p>스칼라의 Typeclass 인스턴스를 정의하는 위치는 컴파일 속도에 큰 영향을 미칩니다. 인스턴스를 Companion Object에 정의하는 것이 다른 위치(별도 trait 또는 object)에 정의하고 import/extends 하는 방식보다 컴파일 속도에서 유리합니다. 프로파일링 결과, Companion Object에 인스턴스를 정의했을 때 Typer 페이즈의 소요 시간과 Implicit 검색 시간이 크게 단축되었습니다. 예를 들어, 특정 서브 프로젝트의 컴파일 속도를 1.44배 향상시키는 결과를 얻었습니다.</p>\n<p>컴파일러가 Implicit 검색 시 Typeclass 인스턴스를 구분하기 어렵기 때문에, Flamegraph와 같은 도구를 활용하여 Implicit 검색 시간의 비중을 파악하는 것이 도움이 됩니다.</p>\n\n<h2>2. Build Pipelining 적용</h2>\n<p>스칼라 컴파일러의 Build Pipelining 기능은 서브 프로젝트 간 의존성이 있을 때, 후속 프로젝트 컴파일을 위해 이전 프로젝트의 백엔드 단계까지 기다릴 필요 없이 프론트엔드 단계 결과물(AST)을 활용하여 병렬 컴파일을 가능하게 합니다. sbt에서는 <code>ThisBuild / usePipelining := true</code> 설정으로 활성화할 수 있습니다.</p>\n<p>Build Pipelining 적용 시 주의할 점은 다음과 같습니다:</p>\n<ul>\n    <li>매크로 코드 또는 매크로 확장에 사용되는 코드는 Build Pipelining을 방해합니다. 이러한 경우 <code>exportPipelining := false</code> 설정을 통해 순차 컴파일을 유도해야 합니다. sbt 디버그 로그를 통해 매크로로 인한 Pipelining 실패를 확인할 수 있습니다.</li>\n    <li>Typer 페이즈에 소요되는 시간이 적을수록 Pipelining의 효과는 커집니다.</li>\n</ul>\n<p>Build Pipelining을 통해 쿠키런: 킹덤 서버의 전체 컴파일 속도를 1.22배 향상시킬 수 있었습니다.</p>\n\n<h2>결론</h2>\n<p>Typeclass 인스턴스를 Companion Object에 정의하여 Implicit 검색 시간을 줄이고, Build Pipelining을 활용하여 병렬성을 확보하는 것은 스칼라 프로젝트의 빌드 속도를 개선하는 효과적인 방법입니다. 향후에도 빌드 속도 개선을 위한 새로운 방법을 지속적으로 탐색하고 공유할 예정입니다.</p>\n</body>","createdAt":"2025-08-12T16:29:20.725Z","language":"ko"}