{"title":"신용대출 찾기 서비스 제휴사 Mock 서버 개발기 #2","content":"<body>\n<p>This article details how the Toss Financial Marketplace Platform Team Server Developer, Kyungrin Ryu, improved the utilization of mock servers for their partner integrations. The focus is on the challenges faced during integration testing and the solutions implemented to reduce maintenance difficulties.</p>\n\n<h2>Integration Testing Challenges and Solutions</h2>\n<ul>\n  <li><strong>Lack of E2E Automation:</strong> The credit loan search service currently lacks automated End-to-End (E2E) tests. This necessitates manual testing whenever partner code changes, increasing the risk of missed tests.</li>\n  <li><strong>Dockerized Mock Server and GitHub Actions:</strong> To address this, the team opted for running mock servers in a Docker environment and executing integration tests via GitHub Actions.</li>\n  <li><strong>Spring Cloud Config and Profile Management:</strong> A challenge arose with Spring Cloud Config, which injects properties for four environments (Local, Alpha, Staging, Live). Mock servers initially only supported Local and Alpha. To avoid sacrificing the Local environment, crucial for new service integrations, the team implemented a \"mockServerTest\" profile. This custom profile overrides infrastructure information within the Docker environment, allowing for mock server-based integration tests without impacting other environments.</li>\n  <li><strong>JPA Configuration Issues:</strong> In a multi-module project with overlapping package structures for entities across different modules, duplicate entities were being added to DataSources. To prevent this, the `ddl-auto` setting was disabled, and an `init.sql` was used to create only necessary tables upon Spring Application startup.</li>\n  <li><strong>Test Order Dependency:</strong> Integration tests for the credit loan search service inherently require a specific order, particularly the \"preliminary screening application\" funnel. This sequential dependency, if not managed, can significantly lengthen test execution times. To overcome this, the team broke the \"tests must be independent\" principle. The preliminary screening was run only once for all integration tests, and the resulting data was used for testing subsequent funnels. To manage the order of tests within a single class, the `@Order` annotation was used, and for inter-class ordering, JUnit's `@Suite` feature was adopted.</li>\n</ul>\n\n<h2>GitHub Actions for Integration Testing</h2>\n<ul>\n  <li>The team defined two policies for GitHub Actions to enhance visibility of test results:</li>\n  <li>When merging from a feature branch to `develop`, the PR author is notified if tests fail.</li>\n  <li>When merging from `develop` to `master`, the deployment pipeline indicates test success/failure and any partner code changes.</li>\n</ul>\n\n<h2>Automatic Mock Server Data Migration</h2>\n<ul>\n  <li><strong>Problem:</strong> Maintaining mock server data manually is tedious and prone to errors, especially when partner code is modified.</li>\n  <li><strong>Solution:</strong> An automated process was implemented to generate PRs for E2E test data migration and update `init.sql` queries whenever partner code changes occur.</li>\n  <li><strong>Partner Code Change Detection:</strong> GitHub Actions uses `git diff` to detect changes within specific packages.</li>\n  <li><strong>Partner DTO Specification Extraction:</strong> Kotlin Reflections and a custom `@GenerateSchema` annotation are used to scan classes and mark them for schema extraction.</li>\n  <li><strong>JSON Schema Extraction:</strong> The Jackson library's JSON Schema feature was chosen for its ease of use, ability to share schemas across services, and support for annotations like `@JsonPropertyDescription`. Extracted JSON Schemas are uploaded to S3.</li>\n  <li><strong>JSON Sample Data Generation:</strong> Downloaded JSON Schemas are used to create sample data for each partner's funnel. The schema's `id` indicates the partner/funnel, and the `properties` are analyzed to reconstruct `JsonNode`. New `JsonNode`s are merged with existing JSON values, prioritizing existing data.</li>\n  <li><strong>Data Migration:</strong> Generated sample data is used to migrate data for E2E tests, and `init.sql` files are automatically updated.</li>\n  <li><strong>Automatic Pull Request Creation:</strong> The JGit library is used within the application to execute Git commands. For GitHub Enterprise, a GitHub App is used to obtain tokens for authenticated Git operations. This involves creating a GitHub Enterprise App, obtaining a private secret key, converting it to PKCS#8 format, generating an RSA private key, issuing a JWT, and then using the JWT to obtain an Installation Token.</li>\n</ul>\n\n<h2>Overall Flow</h2>\n<p>This automated process handles data migration, `init.sql` updates, and PR creation upon partner DTO changes, significantly reducing the burden of manual test data management and ensuring stable mock server data.</p>\n\n<h2>Conclusion</h2>\n<p>The article summarizes the internal considerations and attempts made to connect mock servers with integration tests and reduce operational costs through data migration automation for the credit loan service. While ideal E2E tests are preferable, pragmatic solutions like multi-profile strategies, Jackson-based JSON Schema extraction, and automated PR generation using JGit and GitHub Apps were crucial in reducing maintenance costs. The team aims to continuously improve test data and structures to maintain a realistic testing environment, similar to actual partner environments.</p>\n</body>","createdAt":"2025-08-27T05:25:00.000+00:00","link":"https://toss.tech/article/credit-loan-partner-mock-server-2","language":"en"}