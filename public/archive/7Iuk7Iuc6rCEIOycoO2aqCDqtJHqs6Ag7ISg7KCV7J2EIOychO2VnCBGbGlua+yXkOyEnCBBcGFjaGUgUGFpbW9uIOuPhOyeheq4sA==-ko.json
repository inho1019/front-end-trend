{"content":"<body>\n  <h1>ADVoost Shopping의 실시간 유효 광고 선정 파이프라인: Apache Flink와 Apache Paimon 활용 경험</h1>\n  <p>본문은 Apache Spark 기반 AI 데이터 파이프라인 구축 중, 실시간 데이터 수집 및 집계를 위해 Apache Flink와 Apache Paimon을 도입한 경험을 공유합니다.</p>\n\n  <h2>ADVoost Shopping 실시간 유효 광고 선정 파이프라인</h2>\n  <ul>\n    <li>유효 광고 애셋 그룹 선정</li>\n    <li>상품 광고 매핑 업데이트</li>\n    <li>로그 수집 및 집계</li>\n  </ul>\n\n  <h2>Paimon을 활용한 실시간 유효 광고 선정 아키텍처</h2>\n  <ul>\n    <li>광고 정보 CDC 데이터를 Kafka에서 Flink로 Consume하여 Paimon에 적재. Paimon의 부분 업데이트 기능 활용.</li>\n    <li>Paimon의 스냅샷, 태그, 변경 로그를 이용한 타임 트래블, 데이터 조인, 집계, 분석 기능 활용.</li>\n    <li>다양한 광고 정보 조인하여 애셋 그룹 기준으로 반정규화된 데이터 생성.</li>\n    <li>Paimon의 rowkind 재정의 기능으로 데이터 실시간 추가/수정/삭제.</li>\n    <li>일별 캠페인 소진량 데이터와 스트리밍 조인하여 실시간 활용.</li>\n  </ul>\n\n  <h2>상품 광고 매핑 업데이트 및 로그 수집/집계</h2>\n  <ul>\n    <li>상품-애셋 그룹 매핑 정보 CDC 데이터를 Kafka에서 Paimon에 추가/수정/삭제 후 Feature Store에 동기화.</li>\n    <li>로그 데이터를 Kafka에서 Paimon에 실시간 적재 후 Spark에서 배치 집계하여 Hive 및 Aerospike에 적재.</li>\n  </ul>\n\n  <h2>집계 데이터 기반 유효 광고 AI Serving</h2>\n  <ul>\n    <li>광고 서버로부터 상품 정보 목록 수신.</li>\n    <li>애셋 그룹 매핑 Feature 조회.</li>\n    <li>유효 애셋 그룹 Feature 조회 및 실시간 유효 애셋 그룹 선정.</li>\n    <li>집계 Feature 조회 및 AI 모델 추론.</li>\n    <li>상품별 모델 결과 기반 광고 성과 최적화된 애셋 그룹 선정 후 광고 송출.</li>\n  </ul>\n\n  <h2>실시간 유효 광고 선정에 Flink + Paimon 도입 이유</h2>\n  <ul>\n    <li>리소스 효율성 및 빠르고 안정적인 파이프라인 구축.</li>\n    <li>Flink의 우수한 실시간 처리 기능 및 레퍼런스.</li>\n    <li>Paimon의 Flink와의 뛰어난 통합성 및 다음과 같은 장점:\n      <ul>\n        <li>실시간 집계, 스키마 진화, 변경 로그 지원.</li>\n        <li>부분 업데이트 기능.</li>\n        <li>실시간 조인 처리 (PK 일치 시 Paimon INSERT로 처리).</li>\n        <li>타임 트래블 지원.</li>\n        <li>Merge on Write 지원.</li>\n        <li>빠른 조회 (삭제 벡터 조합).</li>\n        <li>테이블 자동 관리 (compaction, 태그, 파티션/스냅샷 만료).</li>\n        <li>Flink 신규 기능 최신 지원 (예: 구체화된 테이블).</li>\n      </ul>\n    </li>\n    <li>Flink의 스트림 기반 처리 및 Paimon의 exactly-once 처리 보장 (consumer-id 활용).</li>\n    <li>중간 데이터 활용 용이성 (Kafka 대체, 디버깅, 데이터 분석, ML 개발).</li>\n    <li>Flink, Spark 모두 지원하여 익숙한 사용 환경.</li>\n  </ul>\n\n  <h2>Paimon 살펴보기</h2>\n  <ul>\n    <li>LSM 트리 구조 기반의 레이크하우스 포맷, 실시간 트랜잭션 처리 강화.</li>\n    <li>파일 구조: 데이터베이스, 테이블, 버킷, 인덱스, 매니페스트, 스키마, 스냅샷.</li>\n    <li>스냅샷: 스키마, 매니페스트 목록 포함.</li>\n    <li>매니페스트 목록: 매니페스트 파일 메타 정보 포함.</li>\n    <li>매니페스트: 데이터 파일, 변경 로그, 테이블 인덱스 메타 정보 포함.</li>\n    <li>데이터 파일: 실제 데이터 포함.</li>\n    <li>변경 로그: 데이터 파일 변경 이력 포함.</li>\n    <li>테이블 인덱스: 동적 버킷 인덱스, 삭제 벡터 포함.</li>\n    <li>삭제 벡터: 삭제된 레코드 위치 포함.</li>\n    <li>자동 compaction: 쓰기 성능 확보 및 쿼리 성능 유지.</li>\n    <li>compaction 전략: Lookup, Full, Asynchronous, Record-Level Expire.</li>\n    <li>PK 테이블 compaction 트리거 조건: num-sorted-run, sort-spill-threshold.</li>\n    <li>테이블 종류: PK 테이블, PK 없는 테이블(append-only).</li>\n    <li>PK 테이블 모드: Copy on Write, Merge on Read, Merge on Write (삭제 벡터 활용).</li>\n    <li>PK 없는 테이블: 로그성 데이터 적재 적합, LSM 트리 미사용.</li>\n    <li>변경 로그 프로듀서: none, input, lookup, full-compaction.</li>\n    <li>Paimon vs Iceberg 성능 비교: 쓰기 성능 (Merge on Read, Merge on Write, 변경 로그), 읽기 성능 (compaction, 삭제 벡터 효과).</li>\n    <li>Paimon 옵션: 버킷 설정 (shuffle & sort 방지), 파일 프루닝 (파티션, 버킷, 매니페스트 집계값, 블룸 필터).</li>\n    <li>파티션 만료 (retention 관리): values-time, update-time 모드.</li>\n    <li>자동 태깅 기능: 이력 데이터 조회 용이성.</li>\n    <li>감사 로그(audit log) 활용: 스냅샷 사이 변경분 조회.</li>\n    <li>consumer-id: 스트리밍 환경에서 exactly-once 보장 (스냅샷 기반 오프셋 관리).</li>\n    <li>실시간 집계 (Paimon merge-engine): sum, collect 함수 등 활용.</li>\n  </ul>\n\n  <h2>운영 중 겪은 이슈 및 개선 사항</h2>\n  <ul>\n    <li>Spark 배치 접근 오류 (1.0 이전, 1.1에서 해결).</li>\n    <li>스키마 진화 (Map 타입 관련 버그, 1.1에서 수정, DataStream API 사용 권장).</li>\n  </ul>\n\n  <h2>Paimon 사용 시 좋았던 점 및 향후 계획</h2>\n  <ul>\n    <li>테이블 관리 작업 불필요 (compaction, 태그, 파티션 만료 자동화).</li>\n    <li>Flink과의 뛰어난 궁합 및 실시간 처리 기능 (부분 업데이트, rowkind, consumer-id).</li>\n    <li>문서 및 커뮤니티 지원 개선.</li>\n    <li>향후 계획: Spark와 Iceberg 연동 개선, Spark 배치 처리 성능 비교.</li>\n  </ul>\n</body>\n</html>","createdAt":"2025-08-13T00:41:36.822Z","language":"ko"}