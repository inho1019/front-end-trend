{"content":"<body>\n  <h2>\n    <strong>gRPC와 JavaScript Proxy를 활용한 웹 기반 게임 Admin 통신 최적화</strong>\n  </h2>\n  <p>\n    본 글은 웹 기반 게임 Admin에서 gRPC 게임 서버와 효과적으로 통신하기 위해 JavaScript의 Proxy API를 활용하는 방법을 소개합니다.\n  </p>\n  <h3>\n    <strong>기존 아키텍처 및 문제점</strong>\n  </h3>\n  <ul>\n    <li>\n      <div>\n        기존에는 REST API가 주로 사용되었으나, 실시간 대량 데이터 처리에 적합하지 않아 gRPC를 채택했습니다.\n      </div>\n    </li>\n    <li>\n      <div>\n        gRPC는 HTTP/2와 Protocol Buffers(protobuf)를 사용하여 바이너리 형태의 직렬화된 데이터를 전송합니다.\n      </div>\n    </li>\n    <li>\n      <div>\n        브라우저가 gRPC의 커스텀 헤더를 지원하지 않아 Admin Backend(Admin BE)를 프록시 서버로 사용해야 합니다.\n      </div>\n    </li>\n    <li>\n      <div>\n        Protobuf code-gen 라이브러리가 Node.js 런타임을 대상으로 하므로, FE ↔ BE 통신 시 code-gen을 활용하지 못하고 gRPC 메소드 추가 시마다 REST API endpoint를 직접 추가해야 하는 번거로움이 있었습니다.\n      </div>\n    </li>\n  </ul>\n  <h3>\n    <strong>아이디어</strong>\n  </h3>\n  <ul>\n    <li>\n      <div>\n        BE용 API 클라이언트의 타입 정보를 활용하여 브라우저에서도 동일하게 동작하는 클라이언트를 자동으로 생성하는 것을 목표로 했습니다.\n      </div>\n    </li>\n    <li>\n      <div>\n        Protobuf parser를 이용한 code-gen 대신, 이미 존재하는 타입 정보를 기반으로 각 endpoint에 1:1 대응하는 JS 코드를 생성하지 않고, 런타임에 동적으로 동작하는 클라이언트를 구현하고자 했습니다.\n      </div>\n    </li>\n    <li>\n      <div>\n        FE 클라이언트가 BE 클라이언트와 동일한 타입 시그니처를 가지도록 하고, code-gen 없이 런타임에 동적으로 BE의 함수를 호출하도록 설계했습니다.\n      </div>\n    </li>\n  </ul>\n  <h3>\n    <strong>구현</strong>\n  </h3>\n  <ul>\n    <li>\n      <div>\n        JavaScript의 Proxy API를 사용하여 객체의 기본 동작을 재정의했습니다.\n      </div>\n    </li>\n    <li>\n      <div>\n        Proxy의 <code>get()</code> handler를 사용하여 프로퍼티 접근 경로를 반환하고, 재귀적으로 Proxy를 생성하여 다단계 프로퍼티 접근을 구현했습니다.\n      </div>\n    </li>\n    <li>\n      <div>\n        Proxy의 <code>apply()</code> handler를 사용하여 함수의 호출을 재정의하고, 실제 RPC 호출을 수행하도록 구현했습니다.\n      </div>\n    </li>\n    <li>\n      <div>\n        이를 통해 <code>feClient.serviceA.method1(payload)</code>와 같이 실제 API가 존재하는 것처럼 개발자에게 동일한 개발 경험을 제공했습니다.\n      </div>\n    </li>\n  </ul>\n  <h3>\n    <strong>Further (추가 최적화)</strong>\n  </h3>\n  <ul>\n    <li>\n      <div>\n        code-gen으로 생성되는 방대한 JavaScript 코드 대신, Protobuf 스키마를 JSON 형태로 생성하고 이를 기반으로 동작하는 함수를 사용하는 방안을 고려했습니다.\n      </div>\n    </li>\n    <li>\n      <div>\n        Protobufjs의 reflection 기능을 활용하여 런타임에 동적으로 proto → JS 변환을 가능하게 함으로써 기존 Proxy 객체를 재사용하여 동일한 타입과 동작을 가진 함수를 완성할 수 있었습니다.\n      </div>\n    </li>\n  </ul>\n  <h3>\n    <strong>결론</strong>\n  </h3>\n  <ul>\n    <li>\n      <div>\n        이 방법을 통해 쿠키런: 킹덤 운영툴은 FE와 BE를 합쳐 약 100만 줄의 JavaScript 코드를 삭제하고, 개발자는 endpoint 작성의 번거로움에서 벗어날 수 있었습니다.\n      </div>\n    </li>\n    <li>\n      <div>\n        TypeScript의 컴파일 타임 안전성과 메타데이터의 런타임 보호를 통해 JavaScript스럽게 문제를 해결했습니다.\n      </div>\n    </li>\n  </ul>\n</body>","createdAt":"2025-08-12T16:19:21.822Z","language":"ko"}