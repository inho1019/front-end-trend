{"content":"<p>제조업에서 여러 시스템에 걸쳐 관련 정보에 빠르고 정확하게 접근하는 능력은 매우 중요합니다. 하지만 기존 검색 엔진은 데이터 사일로로 인해 결함 로그, 운영 데이터, 비용 분석 간의 연관성을 파악하기 어렵다는 문제점이 있습니다. 이러한 데이터 파편화는 의사 결정과 운영 효율성을 저해할 수 있습니다.</p>\n<p>인공지능(AI)과 고급 검색 기술을 활용하면 제조업체는 데이터 사일로를 해소하고 핵심 인사이트에 대한 액세스를 중앙 집중화할 수 있습니다. 자연어 처리(NLP)를 활용하는 AI 기반 검색 엔진을 통해 제조 팀은 결함 유형, 심각도, 추세, 수리 비용 등을 보다 직관적이고 사람처럼 쿼리할 수 있습니다. 이러한 접근 방식은 제조업체가 다음과 같은 이점을 누릴 수 있도록 합니다.</p>\n<ul>\n  <li>결함 식별 및 해결에 대한 응답 시간 개선</li>\n  <li>분산된 데이터 소스에서 관련 인사이트를 제공하여 유지보수 워크플로우 최적화</li>\n  <li>중요 문제를 완화하기 위한 실행 가능한 인사이트를 신속하게 찾아 다운타임 감소</li>\n  <li>결함 데이터의 패턴 및 추세를 파악하여 품질 보증 간소화</li>\n</ul>\n<p>이 블로그에서는 AWS Amplify, Amazon Bedrock, Amazon OpenSearch를 사용하여 검색 엔진을 구축하는 방법을 다룹니다. 특히 다양한 제품의 결함 추적을 포함하는 제조 데이터셋에 중점을 둡니다. 이 데이터를 사용하여 결함 유형, 심각도 및 관련 수리 비용을 쿼리하는 방법을 배웁니다. AWS Amplify Gen 2는 AWS Cloud Development Kit (CDK)를 기반으로 하여 유연성을 향상시키고 백엔드 리소스를 사용자 정의하고 다양한 AWS 서비스를 통합하여 강력한 애플리케이션을 구축할 수 있도록 합니다. 결함 추세를 감지하거나 검사 방법을 최적화하는 경우, 생성형 AI가 제조 워크플로우를 어떻게 변화시킬 수 있는지 알 수 있습니다.</p>\n<p>AI 기반 검색 엔진을 만들기 위해 다음과 같은 AWS 기술을 활용합니다.</p>\n<ul>\n  <li><strong>AWS Amplify:</strong> 개발자가 안전한 전체 스택 애플리케이션을 구축, 배포 및 관리하는 데 도움이 되는 포괄적인 도구 및 서비스 모음입니다. Amazon Cognito를 사용한 사용자 인증 및 권한 부여를 포함한 AWS 서비스와 통합됩니다. AWS Amplify는 스토리지 및 API 관리를 위한 Amazon S3 및 AWS AppSync와 같은 다른 서비스와의 원활한 통합도 지원합니다.</li>\n  <li><strong>Amazon Bedrock:</strong> 고성능 파운데이션 모델(FM)을 제공하는 AI 서비스입니다. Amazon Bedrock은 여러 데이터 소스와 연결하여 지식 베이스(KB)를 형성합니다. 이 앱에서는 S3를 사용하여 결함 데이터를 저장하고, Amazon Bedrock에서 처리 및 색인화하여 지능적인 검색 및 응답을 가능하게 합니다.</li>\n  <li><strong>Amazon OpenSearch Service:</strong> 전문적인 전체 텍스트 검색 및 분석을 지원하는 유연하고 확장 가능한 검색 엔진입니다. Amazon Bedrock이 지식 베이스에서 관련 데이터를 검색한 후, 최적화된 쿼리를 위해 OpenSearch Service로 벡터화된 결과를 보내 효율적이고 정확한 결함 감지, 분석 및 문제 해결을 가능하게 합니다.</li>\n  <li><strong>Amazon Simple Storage (S3):</strong> 결함 로그와 같은 데이터를 저장하는 데 사용되는 확장 가능한 스토리지 솔루션입니다. Amazon S3는 제조 결함 데이터에 대한 기본 스토리지 솔루션 역할을 하며, Amazon Bedrock에 정보를 공급하여 검색 엔진에서 사용하는 지식 베이스를 생성합니다.</li>\n</ul>\n<p>이러한 AWS 서비스를 결합하면 데이터를 색인화하고 검색할 뿐만 아니라 사용자 쿼리 의도를 이해하여 보다 정확하고 문맥적으로 관련성 있는 결과를 제공하는 검색 엔진을 만들 수 있습니다. AI 기반 검색 엔진은 제조 고객이 다운타임을 줄이고 결함 감지를 최적화하며 제품 품질을 개선하는 데 도움이 될 수 있습니다. AWS Amplify의 확장성을 통해 제조 워크플로우에 맞춰진 사용자 정의 실시간 애플리케이션을 구축하여 결함을 추적하고 생산 프로세스를 간소화할 수 있습니다.</p>\n<p><strong>사전 요구 사항</strong></p>\n<ul>\n  <li>AWS 계정: AWS Amplify는 AWS 무료 등급에 포함됩니다.</li>\n  <li>설치: npm (v9 이상) 및 git (v2.14.1 이상)</li>\n  <li>텍스트 편집기: 이 가이드에서는 VSCode를 사용하지만 선호하는 IDE를 사용할 수 있습니다.</li>\n  <li>예제 데이터셋: Kaggle에서 제공하는 제조 결함 데이터 파일의 제조 결함 데이터를 활용합니다. 하지만 사이트에서 제공하는 다른 데이터셋을 자유롭게 탐색하여 필요에 맞는 것을 찾으십시오.</li>\n  <li>Amazon Bedrock 모델 액세스: 이 가이드에는 Amazon Titan Text Embeddings V2 및 Anthropic Claude 3 Haiku 모델에 대한 액세스가 필요합니다. 나열된 모델에 대한 액세스를 요청하려면 Amazon Bedrock 모델 액세스를 방문하십시오.</li>\n</ul>\n<p><strong>리포지토리 복제</strong></p>\n<ol>\n  <li>AWS 샘플의 리포지토리로 이동하여 GitHub 리포지토리에 포크합니다.</li>\n  <li>터미널에서 다음 명령을 실행하여 앱을 복제합니다.</li>\n</ol>\n<pre><code>git clone https://github.com//amplify-genai-manufacturing-search.git\n</code></pre>\n<ol start=\"3\">\n  <li>터미널에서 다음 명령을 실행하여 VSCode에서 새로 복제된 리포지토리에 액세스합니다.</li>\n</ol>\n<pre><code>cd amplify-genai-manufacturing-search\ncode . -r\n</code></pre>\n<p>VSCode에서 Amplify 폴더를 포함한 리포지토리 폴더가 열립니다. 이 폴더에는 다음 섹션에서 검토할 앱 코드가 포함되어 있습니다.</p>\n<ol start=\"4\">\n  <li>다음 명령을 실행하여 Amplify Gen2 패키지를 포함한 필수 패키지를 설치합니다.</li>\n</ol>\n<pre><code>npm i\n</code></pre>\n<p><strong>Amplify 백엔드</strong></p>\n<p>최종 앱 (게시물 시작 부분의 GIF 참조)에서 사용자는 쿼리를 입력하고 버튼을 클릭하여 Amazon Bedrock 지식 베이스에서 관련 정보를 요청합니다. 해당 코드는 복제한 리포지토리에 있습니다. 여기서는 Amplify로 개발 및 호스팅된 검색 엔진 앱을 만들기 위한 주요 단계를 검토합니다. 리포지토리에서 데이터 디렉토리가 포함된 Amplify 폴더를 찾을 수 있습니다.</p>\n<p><code>amplify/auth/resource.ts</code> 파일에서 인증은 사용자가 애플리케이션에 액세스하고 파일을 업로드하려면 이메일로 로그인하도록 요구하도록 구성됩니다. 이메일 기반 로그인을 활성화하여 인증된 사용자만 민감한 데이터 및 기능과 상호 작용하도록 합니다.</p>\n<pre><code class=\"language-typescript\">import { defineAuth } from '@aws-amplify/backend';\n \nexport const auth = defineAuth({\n    loginWith: {\n        email: true,\n    },\n});\n</code></pre>\n<p>다음으로 <code>amplify/data/resource.ts</code> 파일에서 센서 판독값 또는 결함 데이터 목록을 수신하고 Amazon Bedrock과 연결하여 사용자에게 맥락적으로 관련성 있는 응답을 생성하는 GraphQL 쿼리를 찾을 수 있습니다. GraphQL API 스키마는 두 부분으로 구성됩니다.</p>\n<ul>\n  <li><strong>generateHaiku 쿼리:</strong> 이 쿼리는 <code>prompt</code>라는 문자열 인수를 받아 Claude Haiku에서 생성된 응답을 문자열로 반환합니다. <code>.authorization((allow) => [allow.authenticated()])</code>를 사용하여 인증된 사용자만 검색 엔진을 쿼리하도록 액세스를 제한합니다. 이는 공개 API 키에 의존하는 대신 Amazon Cognito 사용자 풀을 활용하여 보다 강력한 액세스 제어를 통해 보안을 강화합니다. <code>.handler(a.handler.function(generateHaikuFunction))</code>는 제공된 프롬프트를 기반으로 응답을 처리합니다.</li>\n  <li><strong>API 스키마 구성:</strong> 스키마는 <code>generateHaiku</code> 쿼리가 구성된 <code>a.schema</code>를 사용하여 정의됩니다. API의 기본 권한 부여 모드는 <code>authorizationModes</code> 구성에 지정된 <code>userPools</code>를 사용하도록 설정됩니다.</li>\n</ul>\n<pre><code class=\"language-typescript\">import { type ClientSchema, a, defineData } from \"@aws-amplify/backend\";\nimport { generateHaikuFunction } from \"../functions/generateFunction/resource\";\n\nconst schema = a.schema({\n  generateHaiku: a.query()\n    .arguments({ prompt: a.string().required() })\n    .returns(a.string())\n    .authorization((allow) => => [allow.authenticated()])\n    .handler(a.handler.function(generateHaikuFunction)),\n});\nexport type Schema = ClientSchema;\nexport const data = defineData({\n  schema,\n  authorizationModes: {\n    defaultAuthorizationMode: \"userPool\",\n  },\n});\n</code></pre>\n<p><code>amplify/functions/generateFunction/resource.ts</code> 파일은 사용자 정의 GraphQL 쿼리를 해결하는 핸들러가 포함된 Lambda 함수를 정의합니다.<code>handler.ts</code></p>\n<pre><code class=\"language-typescript\">import { defineFunction } from '@aws-amplify/backend';\n\nexport const generateHaikuFunction = defineFunction({\n    name: 'generate-haiku',\n    entry: './handler.ts',\n    timeoutSeconds: 60\n});\n</code></pre>\n<p><code>handler.ts</code> 함수에서 AWS SDK의 Agent Runtime 클라이언트에 있는 <code>RetrieveAndGenerateCommand</code>를 사용하여 Amazon Bedrock 지식 베이스에서 관련 데이터를 검색하고, 미리 정의된 템플릿으로 사용자 입력을 구성하고, 검색된 정보를 기반으로 응답을 생성합니다. 세션은 AWS Key Management Service (KMS) 키로 보호되며, 함수는 응답을 구문 분석하여 생성된 데이터 및 출처를 구조화된 출력으로 추출합니다.</p>\n<pre><code class=\"language-typescript\">import type { Schema } from \"../../data/resource\";\n \nimport {\n    BedrockAgentRuntimeClient,\n    RetrieveAndGenerateCommand,\n    RetrieveAndGenerateCommandInput,\n    PromptTemplate\n} from \"@aws-sdk/client-bedrock-agent-runtime\";\nconst client = new BedrockAgentRuntimeClient();\nexport const handler: Schema[\"generateHaiku\"][\"functionHandler\"] = async (\n    event,\n) => {\n    const prompt = event.arguments.prompt;\nconst promptTemplate: PromptTemplate = {\n    textPromptTemplate: `\n        Based on the following search results:\n        $search_results$\n        Respond to the specific query, focusing on the relevant information based on the search results.\n        If the query asks about repair costs, format the repair cost as follows: include a $ sign before the amount.\n        Example for repair cost:\n        Defect ID: 176, Product ID: 13, Defect Type: Structural, Date: 3/9/2024, Location: Surface, Severity: Critical, Inspection Method: Manual Testing, Repair Cost: $952.49\n        Respond directly to the query, and only include relevant fields such as defect severity, inspection type, or trends if applicable.\n        Respond only if the search results are relevant. Do not respond to queries outside of the search results.\n        Do not include introductory phrases like 'Here is a haiku' or 'From haiku'. Respond directly to the query.`,\n};\n\nconst input: RetrieveAndGenerateCommandInput = {\n    input: {\n        text: prompt,\n    },\n\n    retrieveAndGenerateConfiguration: {\n        type: \"KNOWLEDGE_BASE\",\n        knowledgeBaseConfiguration: {\n            knowledgeBaseId: process.env.KNOWLEDGE_BASE_ID!,\n            modelArn: process.env.MODEL_ARN!,\n            retrievalConfiguration: {\n                vectorSearchConfiguration: {\n                    numberOfResults: 10\n                },\n            },\n            generationConfiguration: {\n                promptTemplate,\n                inferenceConfig: {\n                    textInferenceConfig: {\n                        temperature: 0.7,\n                        maxTokens: 150,\n                    },\n                },\n            },\n        },\n    },\n    sessionConfiguration: {\n        kmsKeyArn: process.env.KMS_KEY!,\n    },\n};\n\nconst command = new RetrieveAndGenerateCommand(input);\n\nconst response = await client.send(command);\n\nconst generatedText = response.output?.text || \"The query does not match any known results.\";\n\nconst citations = response.citations?.map((citation, index) => {\n    const location = citation.retrievedReferences?.[0]?.location;\n    if (location) {\n        const s3Uri = location.s3Location?.uri || \"\";\n        return `${index + 1}. ${s3Uri}`;\n    } else {\n        return `${index + 1}.`;\n    }\n}).join(\"\\n\") || \"No citations available\";\n\nreturn `${generatedText}\\n\\nCitations:\\n${citations}`;\n\n};\n</code></pre>\n<p><code>amplify/storage/resource.ts</code> 파일에서는 파일 스토리지 관리를 위한 Amplify Storage를 구성하고 업로드와 같은 필수 작업을 활성화합니다. <code>defineStorage</code> 함수를 사용하여 내부 참조를 위한 사용자 친화적인 이름으로 스토리지를 인스턴스화합니다. AWS Amplify가 버킷에 대한 고유 식별자를 생성하지만, 버킷 이름을 제공하면 앱의 백엔드 구성 내에서 식별하는 데 도움이 됩니다. 버킷은 인증된 사용자가 <code>public/*</code> 경로에 읽기 및 쓰기를 할 수 있도록 설정되어 샘플 검색 데이터를 저장합니다.</p>\n<pre><code class=\"language-typescript\">import { defineStorage } from \"@aws-amplify/backend\";\n \nexport const storage = defineStorage({\n    name: \"amplify-search-tool-storage\",\n    access: (allow) => ({\n        'public/*': [\n            allow.authenticated.to(['read', 'write'])\n        ]\n    })\n});\n</code></pre>\n<p><code>amplify/backend.ts</code>에서는 CDK 라이브러리를 가져와 애플리케이션의 다양한 측면을 구성합니다. aws-iam 라이브러리는 권한 관리, aws-kms 세션 관리, aws-opensearchserverless Amazon OpenSearch Service 구성, aws-bedrock 응답 생성 지원에 사용됩니다. 각 라이브러리는 애플리케이션이 올바르게 구성되도록 고유한 목적을 수행합니다.</p>\n<pre><code class=\"language-typescript\">import * as kms from 'aws-cdk-lib/aws-kms';\nimport * as iam from 'aws-cdk-lib/aws-iam';\nimport * as opensearchserverless from 'aws-cdk-lib/aws-opensearchserverless'\n\n// /* AWS CDK LIBRARIES FOR 2ND DEPLOYMENT */\n// import * as bedrock from 'aws-cdk-lib/aws-bedrock';\n// import { Effect, PolicyStatement } from \"aws-cdk-lib/aws-iam\";\n</code></pre>\n<p>다음으로 <code>backend.createStack()</code> 메서드를 사용하여 백엔드가 사용자 정의 리소스를 수용할 새 CloudFormation 스택을 생성하도록 지시합니다. AWS Amplify Gen 2를 사용하면 CDK를 사용하여 사용자 정의 리소스를 생성할 수 있으며, Amplify 라이브러리 이외의 서비스를 사용할 수 있습니다. 스택은 CloudFormation 템플릿을 기반으로 하여 확장성을 제공합니다. 예를 들어, AI 관련 서비스를 위한 생성형 AI 스택과 Cognito 리소스를 관리하기 위한 인증 스택을 생성하여 논리적으로 구성한 후 사용자 정의 AWS 리소스를 추가할 수 있습니다. 이제 사용자 정의 AWS 리소스를 정의하기 시작할 수 있습니다!</p>\n<p><code>customResourceStack</code> 내에서 Amazon OpenSearch Serverless의 <code>CfnAccessPolicy</code>를 정의하여 인덱스와 컬렉션을 모두 관리하는 데 필요한 권한을 명시합니다. 이 정책의 <code>Principal</code>은 <code>arn:aws:iam::${customResourceStack.account}:role/Admin</code>으로 설정되어 지정된 IAM 역할과 권한이 있는 승인된 엔티티만 인덱스 및 컬렉션 생성, 업데이트, 삭제와 같은 중요한 작업을 수행할 수 있도록 합니다.</p>\n<p>액세스 정책 외에도 OpenSearch Service 컬렉션에 대한 암호화 설정을 지정하는 <code>CfnSecurityPolicy</code>를 정의합니다. 이 정책은 Amplify-aoss-collection 컬렉션에 저장된 모든 데이터가 AWS 소유 키를 사용하여 암호화되도록 하여 키 관리를 단순화하는 동시에 저장된 데이터를 보호합니다.</p>\n<pre><code class=\"language-typescript\">const accessPolicy = new opensearchserverless.CfnAccessPolicy(customResourceStack, 'OpenSearchAccessPolicy', {\n  name: 'collection-policy',\n  type: 'data',\n  description: 'Access policy for collection',\n  policy: JSON.stringify([{\n    Description: 'Access for test-user',\n    Rules: [\n      {\n        ResourceType: 'index',\n        Resource: ['index/amplify-aoss-collection/*'],\n        Permission: [\n          'aoss:CreateIndex',\n          'aoss:DeleteIndex',\n          'aoss:UpdateIndex',\n          'aoss:DescribeIndex',\n          'aoss:ReadDocument',\n          'aoss:WriteDocument'\n        ]\n      },\n      {\n        ResourceType: 'collection',\n        Resource: ['collection/amplify-aoss-collection'],\n        Permission: [\n          'aoss:CreateCollectionItems',\n          'aoss:DeleteCollectionItems',\n          'aoss:UpdateCollectionItems',\n          'aoss:DescribeCollectionItems'\n        ]\n      }\n    ],\n    /* REPLACE  WITH THE DEFAULT PRINCIPAL */\n    Principal: [permissions.roleArn,`arn:aws:iam::${customResourceStack.account}:role/Admin`],\n  }])\n});\n \n/* DEFINE AMAZON OPENSEARCH SECURITY POLICY */\nconst securityPolicy = new opensearchserverless.CfnSecurityPolicy(customResourceStack, 'OpenSearchSecurityPolicy', {\n  description: 'Security policy for my-collection',\n  name: 'amplify-security-policy',\n  type: 'encryption',\n  policy: JSON.stringify({\n    Rules: [\n      {\n        ResourceType: 'collection',\n        Resource: ['collection/amplify-aoss-collection'],\n      }\n    ],\n    AWSOwnedKey: true,\n  })\n});\n</code></pre>\n<p>컬렉션은 하나 이상의 인덱스 그룹으로, 분석 워크로드를 나타냅니다. 이 컬렉션은 검색 엔진 데이터에 대한 확장 가능하고 효율적인 스토리지 솔루션 역할을 하여 빠른 검색 작업을 지원하고 높은 가용성을 보장합니다. <code>CfnCollection</code> 구성을 지정하면 데이터 스토리지 및 검색 기능의 기반을 마련할 수 있습니다.</p>\n<pre><code class=\"language-typescript\">const collection = new opensearchserverless.CfnCollection(customResourceStack, 'OpenSearchCollection', {\n  name: 'amplify-aoss-collection',\n  type: 'VECTORSEARCH',\n  description: 'Collection for amplify search tool',\n});\n</code></pre>\n<p>앱을 실행하면 (다음 섹션에서 설명하는 대로) <code>amplify_outputs.json</code>이라는 파일이 자동으로 생성됩니다. 이 파일에는 API 엔드포인트 및 인증 메타데이터 세부 정보가 포함됩니다. <code>src/app/App.tsx</code>에서는 AWS Amplify 클라이언트 라이브러리를 초기화하고 구성한 다음, 완전한 형식의 API 요청을 AWS Amplify 백엔드로 처리하기 위한 데이터 클라이언트를 생성합니다. <code>client.queries.generateHaiku</code> 메서드를 사용하여 <code>handleSearch</code> 함수에서 쿼리가 실행됩니다.</p>\n<pre><code class=\"language-typescript\">import { Amplify } from 'aws-amplify';\nimport outputs from '../amplify_outputs.json';\nimport { generateClient } from \"aws-amplify/api\";\nimport { Schema } from \"../amplify/data/resource\";\n \nAmplify.configure(outputs);\nconst client = generateClient();\nconst App: React.FC = () => {\n  const [messages, setMessages] = useState([]);\n  const handleSearch = async (query: string) => {\n    if (!query.trim()) {\n      setMessages((prevMessages) => [...prevMessages, { user: 'bot', text: 'Query cannot be empty.' }]);\n      return;\n    }\ntry {\n  const { data, errors } = await client.queries.generateHaiku({ prompt: query });\n\n  if (errors) {\n    throw new Error(`Error from Bedrock: ${errors[0].message}`);\n  }\n\n  setMessages((prevMessages) => [...prevMessages, { user: 'bot', text: data || \"No response from AI\" }]);\n} catch (error) {\n  let errorMessage = 'Error fetching data.';\n  if (error instanceof Error) {\n    errorMessage = error.message;\n  }\n  setMessages((prevMessages) => [...prevMessages, { user: 'bot', text: `Error fetching data: ${errorMessage}` }]);\n}\n\n  };\n</code></pre>\n<p><code>src/components/Uploader.tsx</code>에서는 Amplify Storage Manager UI 구성 요소를 통해 사용자 인터페이스에서 Amazon S3 버킷으로 직접 파일 업로드 작업을 간소화합니다. 이 구성 요소는 프로세스를 단순화하여 최소한의 설정으로 강력한 파일 스토리지 기능을 통합할 수 있도록 합니다. 이미지, 문서 또는 기타 파일 유형을 처리하든 Amplify Storage Manager는 업로드 제한 설정, 재개 가능한 업로드 처리, 파일 경로 사용자 정의와 같은 유연한 구성 옵션을 제공합니다.</p>\n<pre><code class=\"language-react\">import React from 'react';\nimport { StorageManager } from '@aws-amplify/ui-react-storage';\nimport '@aws-amplify/ui-react/styles.css';\n \nconst Uploader: React.FC = () => {\n    return (\n        \n            \n        \n    );\n};\nexport default Uploader;\n</code></pre>\n<p><strong>앱 실행</strong></p>\n<ol>\n  <li>Amplify는 각 개발자에게 개인 클라우드 샌드박스 환경을 제공하여 신속한 구축, 테스트 및 반복을 위한 격리된 개발 공간을 제공합니다. 클라우드 샌드박스 환경을 시작하려면 새 터미널 창을 열고 다음 명령을 실행합니다.</li>\n</ol>\n<pre><code>npx ampx sandbox\n</code></pre>\n<ol start=\"2\">\n  <li>다음 명령을 실행하여 로컬 개발 서버를 시작합니다.</li>\n</ol>\n<pre><code>npm run dev\n</code></pre>\n<p>이전 명령을 실행하여 애플리케이션을 시작한 후 Amplify Authenticator 구성 요소의 '계정 만들기' 기능을 사용하여 이메일 주소와 비밀번호를 제공합니다. 확인 이메일을 통해 사용자 설정을 완료한 후 로그인하여 애플리케이션에 액세스합니다.</p>\n<ol start=\"3\">\n  <li>개발 서버에서 앱과 상호 작용한 후 터미널에서 Ctrl + C를 눌러 샌드박스 환경을 중지합니다. 샌드박스 환경의 리소스를 삭제할지 묻는 메시지가 표시되면 'Y'를 입력하여 삭제하십시오.</li>\n</ol>\n<p><strong>백엔드 리소스 배포</strong></p>\n<p>앱이 예상대로 작동하면 'Amplify에 앱 배포 시작하기'의 단계를 따라 백엔드 리소스를 배포합니다. 배포를 위해 GitHub를 리포지토리로 선택해야 합니다.</p>\n<p><strong>샘플 데이터 업로드</strong></p>\n<p>애플리케이션을 배포하고 로그인한 후 Amplify에서 생성한 앱 도메인 URL에 액세스하여 샘플 데이터를 업로드합니다. 파일을 업로드한 후 AWS Amplify 콘솔의 스토리지 섹션에 있는 <code>public/</code> 폴더를 확인하여 업로드를 확인합니다.</p>\n<p><strong>Amazon OpenSearch Serverless에서 벡터 인덱스 생성</strong></p>\n<p>Bedrock 지식 베이스를 정의하기 전에 Amazon OpenSearch 콘솔에서 <code>amplify-aoss-collection</code>에 대한 벡터 인덱스를 생성합니다. (그림 5) 이 인덱스는 텍스트, 이미지 또는 기타 데이터의 숫자 표현인 벡터 임베딩을 저장하고 검색합니다. 벡터 필드 이름 (임베딩 저장용), 벡터 차원 (최대 16,000), 거리 측정 기준 (예: 유클리드, 코사인 또는 점곱)을 정의하여 OpenSearch Service 컬렉션을 효율적이고 정확한 검색 작업을 위해 최적화합니다.</p>\n<p><strong>Amazon Bedrock 지식 베이스 정의</strong></p>\n<p>다음으로 <code>backend.ts</code> 파일에서 <code>CfnKnowledgeBase</code> 구성을 사용하여 구조화 및 비구조화 데이터를 저장하고 관리하는 벡터 지식 베이스를 생성합니다. 여기서는 고급 벡터화 및 검색 기능을 제공하기 위해 지식 베이스를 OpenSearch Serverless 컬렉션과 통합합니다. 이 지식 베이스는 파운데이션 모델이 쿼리하여 정확하고 문맥적으로 관련성 있는 응답을 제공할 수 있는 정보 저장소를 제공합니다.</p>\n<pre><code class=\"language-typescript\">const knowledgeBase = new bedrock.CfnKnowledgeBase(customResourceStack, 'BedrockKB', {\n  knowledgeBaseConfiguration: {\n    type: 'VECTOR',\n    vectorKnowledgeBaseConfiguration: {\n      embeddingModelArn: 'arn:aws:bedrock:us-east-1::foundation-model/amazon.titan-embed-text-v2:0',\n    },\n  },\n  name: 'amplify-search-tool-kb',\n  roleArn: permissions.roleArn,\n  storageConfiguration: {\n    type: 'OPENSEARCH_SERVERLESS',\n    opensearchServerlessConfiguration: {\n      collectionArn: collection.attrArn,\n      vectorIndexName: 'bedrock-knowledge-base-default-index', \n      fieldMapping: {\n        vectorField: 'bedrock-knowledge-base-default-vector',\n        textField: 'AMAZON_BEDROCK_TEXT_CHUNK', \n        metadataField: 'AMAZON_BEDROCK_METADATA', \n    },\n  }\n});\n</code></pre>\n<p>지식 베이스를 생성한 후 Amazon Bedrock 지식 베이스의 데이터 소스로 생성된 Amazon S3 버킷을 정의합니다. 이를 달성하려면 점 표기법을 사용하여 버킷 속성에 액세스하여 버킷의 Amazon 리소스 이름 (ARN)을 검색합니다. 샘플 검색 데이터를 저장하기 위해 Amazon S3 버킷을 구성하면 효율적인 데이터 수집 및 관리가 용이합니다. <code>CfnDataSource</code> 구성을 사용하여 Amazon S3와 지식 베이스 간의 연결을 생성하여 지식 베이스가 업로드된 데이터에 액세스하고 처리할 수 있도록 합니다.</p>\n<pre><code class=\"language-typescript\">new bedrock.CfnDataSource(customResourceStack, 'BedrockDataSource', {\n  name: 'amplify-search-tool-data-source',\n  knowledgeBaseId: knowledgeBase.attrKnowledgeBaseId,\n  dataSourceConfiguration: {\n    type: 'S3',\n    s3Configuration: {\n        bucketArn: backend.storage.resources.bucket.bucketArn,\n    },\n  },\n});\n</code></pre>\n<p><strong>앱 업데이트 배포</strong></p>\n<p>변경 사항을 추가, 커밋 및 푸시하여 업데이트를 완료합니다. 이 작업은 AWS Amplify에서 배포를 자동으로 트리거하여 앱이 최신 상태이고 실시간으로 작동하도록 합니다.</p>\n<p><strong>S3 데이터와 Bedrock 지식 베이스 동기화</strong></p>\n<p>앱을 배포한 후 Amazon S3 버킷과 Amazon Bedrock 지식 베이스를 동기화합니다. Amazon Bedrock 콘솔에서 '지식 베이스'로 이동하여 <code>amplify-search-tool-kb</code>를 선택합니다. 그런 다음 '데이터 소스'로 스크롤하여 '동기화'를 선택합니다. (그림 10)</p>\n<p>데이터 소스가 성공적으로 동기화되고 상태가 \"사용 가능\"으로 표시되면 애플리케이션을 통해 검색 엔진을 직접 쿼리할 수 있습니다!</p>\n<p><strong>정리</strong></p>\n<p>AWS Amplify 콘솔로 이동하여 이 블로그에서 생성한 애플리케이션의 \"앱 보기\"를 클릭합니다. 그런 다음 \"앱 설정\"으로 이동하여 \"일반 설정\"으로 이동합니다. 마지막으로 \"앱 삭제\"를 선택하여 애플리케이션 및 관련 백엔드 리소스를 제거합니다. AWS Amplify는 프로젝트의 일부로 생성된 모든 백엔드 리소스를 삭제합니다.</p>\n<p><strong>결론</strong></p>\n<p>AWS Amplify Gen 2, Amazon Bedrock, Amazon OpenSearch Service 및 기타 AWS 서비스를 사용하여 생성형 AI 기반 검색 엔진을 구성하고 배포하는 방법을 배웠으므로 이제 다음 단계를 수행할 차례입니다. Amplify Gen 2 워크샵으로 나만의 사용자 정의 애플리케이션 구축을 시작하고, 개발 노력에 생성형 AI 기반 코딩 도우미 Amazon Q Developer를 활용하는 것을 고려해 보십시오.</p>\n<p>AWS Amplify를 사용하여 AI 기반 애플리케이션을 빠르게 구축할 수 있는 방법을 찾고 계십니까? Amplify AI Kit를 확인하여 아이디어를 그 어느 때보다 빠르게 현실로 만드십시오. 이러한 고급 AI 서비스를 활용하여 향상된 사용자 경험을 제공하는 정교한 검색 기능을 생성하고 배포할 수 있습니다.</p>","createdAt":"2025-08-12T15:55:37.062Z","language":"ko"}