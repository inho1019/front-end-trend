{"content":"<body>\n  <p>네 살이 지나면서 필자의 \"헤드리스 워드프레스 폼 제출\" 글에 포함된 데모가 작동하지 않게 되었다. 이 글은 사용자 정의 프론트엔드를 구축할 때 REST API 엔드포인트를 사용하여 유효성 검사 오류와 제출 피드백을 캡처하고 표시하는 방법을 보여주는 CodePen 임베드를 포함하고 있다. 필자는 백그라운드에서 실행되는 워드프레스 사이트에 의존했지만, 인프라 마이그레이션 중 사이트가 제대로 이전되지 않아 접근 권한을 잃었다.</p>\n  <p>이 문제는 워드프레스가 아닌 경우, 자체 호스팅하거나 수정할 수 없는 제3자 서비스인 경우 어떻게 될까? 서비스 중단 시에도 작동하는 데모를 만들 수 있을까? 교육용 데모를 가능한 오래 유지할 수 있는 방법은 무엇일까? 아니면 데모는 웹상의 다른 모든 것과 마찬가지로 결국 깨지기 마련인가?</p>\n  <p><strong>소프트웨어 테스팅과의 유사점</strong></p>\n  <p>코드에 대한 테스트를 작성하는 사람들은 더 작은 문제와 씨름해왔지만, 근본적으로 문제는 동일하다. 종속성, 특히 제3자 종속성은 제어 범위를 벗어나기 때문에 장애물이 된다. 외부 서비스 자체를 완전히 제거하여 종속성에서 분리하는 것이 가장 확실한 해결책이다. 물론, 이것이 항상 가능한지는 상황에 따라 다르다.</p>\n  <p><strong>REST API 종속성 분리</strong></p>\n  <p>두 가지 가장 일반적인 REST API 종속성 제거 방법은 다음과 같다.</p>\n  <ul>\n    <li>코드 내에서 HTTP 호출을 모킹하고 실제 네트워크 요청 대신 stubbed 응답을 반환합니다.</li>\n    <li>모의 API 서버를 실제 서비스의 대기열로 사용하고 유사한 방식으로 사전 정의된 응답을 제공합니다.</li>\n  </ul>\n  <p><strong>인터셉터를 사용한 응답 모킹</strong></p>\n  <p>Jest 또는 Playwright와 같은 최신 테스팅 프레임워크에는 기본 모킹 기능이 내장되어 있다. 그러나 CodePen에서는 이러한 프레임워크를 사용할 수 없으므로 Fetch API를 monkey patch하여 요청을 가로채고 모의 응답을 반환할 수 있다. monkey patching은 기존 함수를 덮어써서 새 동작을 도입하는 것이다.</p>\n  <p>다음은 구현 예시이다.</p>\n  <pre><code>const fetchWPFormsRestApiInterceptor = (fetch) => async (\n  resource,\n  options = {}\n) => {\n  // We are dealing with the data we expect\n  if (typeof resource !== \"string\" || !(options.body instanceof FormData)) {\n    return fetch(resource, options);\n  }\n\n  if (resource.match(/wp-json\\/contact-form-7/)) {\n    return contactForm7Response(options.body);\n  }\n\n  if (resource.match(/wp-json\\/gf/)) {\n    return gravityFormsResponse(options.body);\n  }\n\n  return fetch(resource, options);\n};\n\nwindow.fetch = fetchWPFormsRestApiInterceptor(window.fetch);</code></pre>\n  <p>이 인터셉터는 특정 조건에 따라 요청이나 응답을 수정한다. 모의 응답을 반환하는 것은 `Response` 객체의 `json` 메서드를 호출하는 것으로 간단하다.</p>\n  <pre><code>const contactForm7Response = (formData) => {\n  const submissionSuccess = {\n    into: \"#\",\n    status: \"mail_sent\",\n    message: \"Thank you for your message. It has been sent.!\",\n    posted_data_hash: \"d52f9f9de995287195409fe6dcde0c50\"\n  };\n  const submissionValidationFailed = {\n    into: \"#\",\n    status: \"validation_failed\",\n    message:\n      \"One or more fields have an error. Please check and try again.\",\n    posted_data_hash: \"\",\n    invalid_fields: []\n  };\n\n  if (!formData.get(\"somebodys-name\")) {\n    submissionValidationFailed.invalid_fields.push({\n      into: \"span.wpcf7-form-control-wrap.somebodys-name\",\n      message: \"This field is required.\",\n      idref: null,\n      error_id: \"-ve-somebodys-name\"\n    });\n  }\n\n  // Or a more thorough way to check the validity of an email address\n  if (!/^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(formData.get(\"any-email\"))) {\n    submissionValidationFailed.invalid_fields.push({\n      into: \"span.wpcf7-form-control-wrap.any-email\",\n      message: \"The email address entered is invalid.\",\n      idref: null,\n      error_id: \"-ve-any-email\"\n    });\n  }\n\n  // The rest of the validations...\n\n  const body = !submissionValidationFailed.invalid_fields.length\n    ? submissionSuccess\n    : submissionValidationFailed;\n\n  return Response.json(body);\n};</code></pre>\n  <p>이제 `wp-json/contact-form-7`과 일치하는 모든 fetch 호출은 폼 입력에 따라 모의 성공 또는 유효성 검사 오류를 반환한다.</p>\n  <p><strong>서버리스를 사용한 모의 API 서버</strong></p>\n  <p>전통적으로 호스팅되는 모의 API 서버를 실행하면 가용성, 유지 관리 및 비용에 대한 문제가 다시 발생한다. 서버리스 함수에 대한 과대광고가 잠잠해졌지만, 이를 사용하여 이러한 문제를 피할 수 있다. DigitalOcean Functions는 관대한 무료 등급을 제공하므로 모의 API를 생성하는 것은 거의 무료이며 수동으로 모의하는 것보다 더 많은 노력이 필요하지 않다.</p>\n  <p>각 엔드포인트에 대해 별도의 함수를 생성하는 것이 더 쉽다. Node.js를 사용할 수 있으며 `contactForm7Response`에 사용한 것과 거의 동일한 기본 코드를 시작할 수 있다.</p>\n  <pre><code>function main(event) {\n  const body = {};\n\n  return { body };\n}</code></pre>\n  <p>엔드포인트가 호출될 때 `main` 함수가 호출된다. 함수는 요청 세부 정보가 포함된 `event` 객체를 인수로 받는다. JSON 응답을 반환하려면 객체를 반환하기만 하면 된다.</p>\n  <p>Multipart/form-data 문자열을 FormData로 변환하려면 `Response` API의 기능을 활용하여 `event.http.body`에서 얻은 base64로 인코딩된 데이터를 디코딩해야 한다.</p>\n  <pre><code>async function convertMultipartFormDataToFormData(data) {\n  const matches = data.match(/^\\s*--(\\S+)/);\n\n  if (!matches) {\n    return new FormData();\n  }\n\n  const boundary = matches[1];\n\n  return new Response(data, {\n    headers: {\n      \"Content-Type\": `multipart/form-data; boundary=${boundary}`\n    }\n  }).formData();\n}\n\nasync function main(event) {\n  const formData = await convertMultipartFormDataToFormData(\n    Buffer.from(event?.http?.body ?? \"\", \"base64\").toString(\"utf8\")\n  );\n\n  // ...\n\n  const body = !submissionValidationFailed.invalid_fields.length\n    ? submissionSuccess\n    : submissionValidationFailed;\n\n  return { body };\n}</code></pre>\n  <p><strong>마무리</strong></p>\n  <p>두 접근 방식 모두 데모를 제3자 API 종속성에서 분리하는 데 도움이 된다. 이 특정 예시에서는 노력이 비슷하다. 수동 모킹 접근 방식은 제어 가능한 종속성조차 포함하지 않고 모든 것이 함께 번들링되므로 외부 종속성이 없다는 사실을 이길 수 없다. 일반적으로 작고 자체 포함된 데모에 이 접근 방식을 선호할 이유가 많다.</p>\n  <p>모의 API 서버를 사용하는 것에도 장점이 있다. 모의 API 서버는 데모뿐만 아니라 다양한 유형의 테스트에도 사용할 수 있다. 더 복잡한 요구 사항의 경우 전용 팀이 모의 API 서버를 작업하는 경우 JavaScript보다 다른 프로그래밍 언어를 선호할 수 있으며, 처음부터 시작하는 대신 WireMock과 같은 도구를 선택할 수 있다.</p>\n  <p>필자는 이 접근 방식을 기본적으로 적용할 필요가 없다고 생각한다. 결국 필자는 CodePen 데모를 4년 동안 문제없이 작동시켰다. 중요한 것은 데모가 언제 중단되는지(모니터링) 알 수 있는 방법과 이를 처리할 수 있는 적절한 도구를 갖추는 것이다.</p>\n</body>","createdAt":"2025-08-17T11:25:00.828Z","language":"ko"}