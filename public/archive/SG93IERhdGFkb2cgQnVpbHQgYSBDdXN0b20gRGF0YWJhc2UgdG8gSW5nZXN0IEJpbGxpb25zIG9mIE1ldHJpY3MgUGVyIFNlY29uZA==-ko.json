{"title":"How Datadog Built a Custom Database to Ingest Billions of Metrics Per Second","content":"<body>\n    <h1>Datadog Monocle: 실시간 시계열 데이터 스토리지 엔진</h1>\n    <p>이 글은 Datadog의 엔지니어링 팀이 대규모 클라우드 모니터링 환경에서 수십억 개의 시계열 데이터를 효율적으로 저장하고 쿼리하기 위해 자체 개발한 맞춤형 시계열 스토리지 엔진인 <strong>Monocle</strong>에 대해 분석합니다.</p>\n\n    <h2>Datadog의 고성능 메트릭스 플랫폼 아키텍처</h2>\n    <ul>\n        <li>Datadog의 메트릭스 플랫폼은 데이터를 수집, 처리, 저장, 제공하는 전체 시스템입니다.</li>\n        <li>데이터는 <strong>Metrics Edge</strong>에서 수신되어 <strong>Storage Router</strong>를 통해 분산 저장됩니다.</li>\n        <li>쿼리의 성격에 따라 두 개의 전문화된 스토리지 시스템으로 분리됩니다.\n            <ul>\n                <li><strong>Long-Term Metrics Storage</strong>: 수개월 또는 수년간의 분석 쿼리를 위한 대규모 기록 보관소입니다.</li>\n                <li><strong>Real-Time Metrics Storage (RTDB)</strong>: 최근 24시간 데이터를 저장하며, 플랫폼 워크로드의 99%를 처리하는 고성능 엔진입니다. 라이브 대시보드 및 자동 모니터링을 지원합니다.</li>\n            </ul>\n        </li>\n        <li>시계열 데이터는 <strong>데이터(타임스탬프 및 값)</strong>와 <strong>메타데이터(태그)</strong>로 구성되며, Datadog는 이를 별도의 데이터베이스에 저장합니다.\n            <ul>\n                <li><strong>Index Database</strong>: 태그(메타데이터)만 저장하여 데이터 검색 속도를 높입니다.</li>\n                <li><strong>Real-Time Timeseries Database (RTDB)</strong>: 타임스탬프와 값만 저장하며, Index Database에서 얻은 스트림 목록을 기반으로 데이터를 검색합니다.</li>\n            </ul>\n        </li>\n    </ul>\n\n    <h2>Apache Kafka를 활용한 아키텍처</h2>\n    <ul>\n        <li>Datadog의 RTDB 클러스터는 <strong>Apache Kafka</strong>를 중심으로 설계되었습니다.</li>\n        <li>Kafka는 데이터베이스 노드 간의 직접적인 통신을 최소화하고 다음 세 가지 핵심 기능을 수행합니다.\n            <ul>\n                <li><strong>데이터 분배</strong>: Kafka의 토픽과 파티션을 사용하여 각 RTDB 노드가 처리할 데이터 세트를 지정합니다.</li>\n                <li><strong>Write-Ahead Log (WAL)</strong>: Kafka를 WAL로 사용하여 데이터 유실 없이 단일 진실 공급원(single source of truth)을 구축합니다.</li>\n                <li><strong>복제</strong>: Kafka의 내장 복제 기능을 활용하여 다른 데이터 센터로 데이터를 자동으로 복사하여 재해 복구를 보장합니다.</li>\n            </ul>\n        </li>\n    </ul>\n\n    <h2>Monocle: Rust 기반 맞춤형 스토리지 엔진</h2>\n    <ul>\n        <li>Monocle은 RTDB 노드의 핵심을 이루는 Datadog의 맞춤형 스토리지 엔진입니다.</li>\n        <li>이전 버전에서 RocksDB를 사용했지만, 특정 요구 사항에 맞춰 성능을 극대화하기 위해 자체 개발했습니다.</li>\n        <li><strong>Rust</strong> 언어로 작성되었으며, <strong>Tokio</strong> 프레임워크를 사용하여 고속 비동기 애플리케이션을 구축했습니다.</li>\n        <li><strong>핵심 데이터 모델: 태그 해싱</strong>\n            <ul>\n                <li>복잡한 태그 문자열 대신 전체 태그 세트를 해싱하여 단일 고유 숫자로 변환합니다.</li>\n                <li>(조직, 메트릭 이름, 태그 해시) -> (타임스탬프, 값 목록) 형식으로 데이터를 저장하여 빠른 조회를 가능하게 합니다.</li>\n            </ul>\n        </li>\n        <li><strong>Monocle 내부</strong>:\n            <ul>\n                <li><strong>동시성 모델</strong>: \"스레드-퍼-코어(thread-per-core)\" 또는 \"공유-없음(shared-nothing)\" 아키텍처를 사용하여 각 CPU 코어가 독립적으로 작동하므로 잠금 및 조정 없이 고성능을 달성합니다.</li>\n                <li><strong>스토리지 구조</strong>: 쓰기 집약적인 워크로드에 효율적인 <strong>Log-Structured Merge-Tree (LSM-Tree)</strong>를 사용합니다.\n                    <ul>\n                        <li><strong>Memtable</strong>: 메모리에서 데이터를 일괄 처리합니다.</li>\n                        <li><strong>Flushing</strong>: Memtable이 가득 차면 디스크에 읽기 전용 파일로 플러시합니다.</li>\n                        <li><strong>Compaction</strong>: 백그라운드 프로세스를 통해 작은 파일을 병합하여 파일을 정리합니다.</li>\n                    </ul>\n                </li>\n                <li><strong>최적화</strong>:\n                    <ul>\n                        <li><strong>Arena Allocator</strong>: Memtable 플러시 시 메모리 할당/해제를 효율적으로 처리합니다.</li>\n                        <li><strong>시간 기반 파일 프루닝</strong>: 최근 데이터에 대한 쿼리가 대부분이므로 시간 범위를 기반으로 불필요한 파일을 빠르게 무시합니다.</li>\n                    </ul>\n                </li>\n            </ul>\n        </li>\n        <li><strong>성능 유지</strong>:\n            <ul>\n                <li><strong>Admission Control</strong>: 시스템 과부하 시 새로운 쿼리 수신을 중단하여 보호합니다.</li>\n                <li><strong>Cost-Based Scheduling</strong>: CoDel 알고리즘을 사용하여 쿼리 우선순위를 지정하고 지연 시간을 관리하여 응답성을 유지합니다.</li>\n            </ul>\n        </li>\n    </ul>\n\n    <h2>향후 계획</h2>\n    <ul>\n        <li><strong>스마트 라우팅</strong>: 동적 로드 밸런싱 시스템을 개발하여 쿼리 \"핫스팟\"에 동적으로 적응합니다.</li>\n        <li><strong>포인트 및 태그 통합</strong>: Index Database와 RTDB를 단일 시스템으로 통합하고, 컬럼 기반 데이터베이스 형식으로 전환하여 분석 속도를 향상시킵니다.</li>\n    </ul>\n    <p>참고: 이 내용은 Datadog 엔지니어링 팀과 P99 컨퍼런스 주최 측의 온라인 공개 정보를 기반으로 분석되었습니다. 원본 자료는 참고 자료 섹션에 링크되어 있습니다.</p>\n</body>","createdAt":"2025-11-04T15:31:09.000+00:00","link":"https://blog.bytebytego.com/p/how-datadog-built-a-custom-database","language":"ko"}