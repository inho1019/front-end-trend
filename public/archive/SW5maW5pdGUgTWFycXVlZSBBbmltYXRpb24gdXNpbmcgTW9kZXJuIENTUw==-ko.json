{"content":"```html\n<p>무한 반복 슬라이드 애니메이션이 있는 로고 세트는 웹 개발의 고전적인 구성 요소입니다. 우리는 <code>&lt;marquee&gt;</code> 요소부터 시작하여 수많은 예제와 구현을 찾을 수 있습니다. 저는 몇 년 전에 직접 이에 대한 기사를 작성했습니다.</p>\n\n<p>“왜 또 기사인가?”라고 물으실 수 있습니다. CSS는 새롭고 강력한 기능으로 계속 발전하고 있으므로 저는 항상 개선과 최적화를 위한 공간을 찾으려고 노력합니다. 이제 몇 가지 새로운 CSS 기능을 사용하여 그렇게 할 것입니다.</p>\n\n<p>작성 시점에서 Chrome 기반 브라우저만 <code>shape()</code>, <code>sibling-index()</code>, <code>sibling-count()</code>와 같은 기능의 전체 지원을 제공합니다.</p>\n\n<p>위의 데모에서는 이미지 수에 관계없이 작동하는 무한 마퀴 애니메이션이 있습니다. HTML에 원하는 만큼 요소를 추가하기만 하면 됩니다. CSS를 건드릴 필요가 없습니다. 변수 하나를 조정하여 표시되는 이미지 수를 쉽게 제어할 수 있으며 반응형입니다. 화면 크기를 조절하면 항목이 부드럽게 조정되는 것을 볼 수 있습니다.</p>\n\n<p>코드가 길고 복잡한 계산으로 가득 차 있다고 생각할 수 있지만, JavaScript 없이 CSS 10줄 미만입니다.</p>\n\n<pre><code class=\"language-css\">.container {\n  --s: 150px; /* 이미지 크기 */\n  --d: 8s; /* 애니메이션 지속 시간 */\n  --n: 4; /* 표시되는 이미지 수 */\n\n  display: flex;\n  overflow: hidden;\n}\nimg {\n  width: var(--s);\n  offset: shape(from calc(var(--s)/-2) 50%,hline by calc(sibling-count()*max(100%/var(--n),var(--s))));\n  animation: x var(--d) linear infinite calc(-1*sibling-index()*var(--d)/sibling-count());\n}\n@keyframes x {\n  to { offset-distance: 100%; }\n}\n</code></pre>\n\n<p>특히 저 이상한 <code>offset</code> 속성 때문에 처음에는 복잡해 보일 수 있습니다! 너무 오래 보지 마세요. 함께 분석해 볼 것이고, 기사가 끝날 때쯤이면 꽤 쉬워 보일 것입니다.</p>\n\n<h3>아이디어</h3>\n\n<p>마퀴를 만들 때 까다로운 부분은 각 요소가 시작점으로 “점프”하여 다시 슬라이드해야 하는 순환 애니메이션을 갖는 것입니다. 이전 구현에서는 무한 애니메이션을 시뮬레이션하기 위해 요소를 복제했지만, 이는 HTML을 조작해야 하고 접근성/성능 문제가 발생할 수 있으므로 좋은 접근 방식이 아닙니다.</p>\n\n<p>일부 최신 구현은 복잡한 translate 애니메이션에 의존하여 보이는 영역 외부로 요소를 “점프”시키고 (사용자는 보지 못함) 보이는 영역 내에서 지속적인 움직임을 유지합니다. 이 접근 방식은 완벽하지만 복잡한 계산이 필요하며 HTML에 있는 요소 수에 따라 달라질 수 있습니다.</p>\n\n<p>“점프”와 함께 지속적인 애니메이션을 만드는 네이티브 방식이 있고 동시에 모든 수의 요소에 대해 작동하면 완벽할 것입니다. 첫 번째 부분은 가능하며 최신 CSS가 필요하지 않습니다. <code>offset</code>을 <code>path()</code>와 결합하여 사용할 수 있으며, 경로는 직선입니다.</p>\n\n<p><code>path</code> 안에서 SVG 구문을 사용하여 선을 정의하고, <code>offset-distance</code>를 0%에서 100% 사이로 애니메이션하여 이미지를 해당 선을 따라 이동시킵니다. 이는 원하는 애니메이션을 가지고 있기 때문에 처음에는 완벽해 보이지만, <code>path()</code>는 하드코딩된 픽셀 값만 허용하므로 유연하지 않은 접근 방식입니다.</p>\n\n<p><code>path()</code>의 한계를 극복하기 위해 새로운 <code>shape()</code> 함수를 사용할 것입니다! 다음은 사양에서 발췌한 내용입니다.</p>\n\n<blockquote>\n<p><code>shape()</code> 함수는 <code>path()</code>에 사용되는 것과 거의 동일한 명령 집합을 사용하지만, 더 표준적인 CSS 구문을 사용하며 추가 단위 및 수학 함수와 같은 CSS 기능의 전체 범위를 허용합니다… 이런 의미에서 <code>shape()</code>는 <code>path()</code>의 상위 집합입니다.</p>\n</blockquote>\n\n<p><code>path()</code>를 사용하여 선을 그리는 대신 <code>shape()</code>를 사용하여 CSS에 의존하고 요소 수에 따라 선을 제어할 수 있습니다.</p>\n\n<p>다음은 <code>shape()</code>를 사용한 이전 데모입니다.</p>\n\n<p><code>shape()</code>에 익숙하지 않다면 걱정하지 마세요. 사용 사례는 매우 기본적인 것으로, 다음 구문을 사용하여 수평 선을 그릴 것입니다.</p>\n\n<pre><code class=\"language-css\">offset: shape(from X Y, hline by length);\n</code></pre>\n\n<p>목표는 X Y 값 (시작점의 좌표)과 길이 값 (선의 길이)을 찾는 것입니다.</p>\n\n<h3>구현</h3>\n\n<p>컨테이너 안의 이미지 세트인 HTML 구조부터 시작하겠습니다.</p>\n\n<pre><code class=\"language-html\">&lt;div class=\"container\"&gt;\n  &lt;img src=\"\"&gt;\n  &lt;img src=\"\"&gt;\n&lt;/div&gt;\n</code></pre>\n\n<p>컨테이너를 flexbox로 만들어 이미지 사이의 기본 공간을 제거하고 컨테이너가 작더라도 줄 바꿈되지 않도록 합니다 (<code>flex-wrap</code>이 기본적으로 <code>nowrap</code>이라는 점을 기억하세요).</p>\n\n<p>이제 한 번에 N개의 이미지만 표시한다고 가정해 보겠습니다. 이를 위해 컨테이너의 너비를 N x 이미지 크기와 같도록 정의해야 합니다.</p>\n\n<pre><code class=\"language-css\">.container {\n  --s: 100px; /* 이미지 크기 */\n  --n: 4; /* 표시되는 이미지 수 */\n\n  display: flex;\n  width: calc(var(--n) * var(--s));\n  overflow: hidden;\n}\nimg {\n  width: var(--s);\n}\n</code></pre>\n\n<p>지금까지는 복잡한 것이 없습니다. 이미지 크기와 표시되는 이미지 수를 제어하는 변수를 도입했습니다. 이제 애니메이션으로 넘어가겠습니다.</p>\n\n<p>지속적인 애니메이션을 얻으려면 선의 길이가 전체 이미지 수에 이미지 하나 크기를 곱한 값과 같아야 합니다. 즉, 모든 이미지를 나란히 포함할 수 있는 선이 있어야 합니다. <code>offset</code> 속성은 이미지 요소에 적용되며, 최신 CSS 덕분에 <code>sibling-count()</code>를 사용하여 전체 이미지 수를 얻을 수 있습니다.</p>\n\n<pre><code class=\"language-css\">offset: shape(from X Y, hline by calc(sibling-count() * var(--s)));\n</code></pre>\n\n<p>X Y 값은 어떻습니까? 0 0을 시도하고 무슨 일이 일어나는지 살펴 보겠습니다.</p>\n\n<p>음, 그리 좋지 않습니다. 모든 이미지가 서로 위에 있고 위치가 약간 벗어났습니다. 첫 번째 문제는 논리적입니다. 동일한 애니메이션을 공유하기 때문입니다. 나중에 지연을 도입하여 수정할 것입니다.</p>\n\n<p><code>offset</code>으로 작업할 때 가장 까다로운 부분은 위치를 정의하는 것입니다. 이 속성은 자식 요소 (이 경우 이미지)에 적용되지만 참조는 부모 컨테이너입니다. 0 0을 지정하면 부모의 왼쪽 상단 모서리를 선의 시작점으로 고려합니다.</p>\n\n<p>이미지는 어떻습니까? 어떻게 배치됩니까? 애니메이션을 제거하고 <code>offset-distance</code>를 0% (기본값)로 유지하면 다음과 같이 보입니다.</p>\n\n<p>이미지의 중심이 0 0에 배치되고 거기서부터 선의 끝까지 수평으로 이동합니다. 선의 위치를 수정하고 이미지를 컨테이너 안으로 가져오기 위해 X Y 값을 업데이트해 보겠습니다. 이를 위해 선은 중앙 0 50%에 있어야 합니다.</p>\n\n<pre><code class=\"language-css\">offset: shape(from 0 50%, hline by calc(sibling-count() * var(--s)));\n</code></pre>\n\n<p>더 나아졌고 이미 지속적인 애니메이션을 볼 수 있습니다. 여전히 완벽하지 않은 것은 왼쪽에 있는 이미지의 “점프”가 보이기 때문입니다. 선의 위치를 수정하여 컨테이너 외부에서 시작하고 이미지의 “점프”가 보이지 않도록 해야 합니다. X 값은 0 대신 -S/2와 같아야 합니다.</p>\n\n<pre><code class=\"language-css\">offset: shape(from calc(var(--s)/-2) 50%, hline by calc(sibling-count() * var(--s)));\n</code></pre>\n\n<p>더 이상 보이는 점프는 없습니다. 애니메이션은 완벽합니다!</p>\n\n<p>이미지 간의 겹침을 수정하려면 각 이미지에 대해 다른 지연을 고려해야 합니다. <code>nth-child()</code>를 사용하여 각 이미지를 개별적으로 선택하고 다음 논리에 따라 지연을 정의할 수 있습니다.</p>\n\n<pre><code class=\"language-css\">img:nth-child(1) {animation-delay: -1 *  duration/total_image }\nimg:nth-child(2) {animation-delay: -2 *  duration/total_image }\n/* 등등 */\n</code></pre>\n\n<p>힘든 작업이죠? 그리고 HTML 코드의 이미지 수만큼 선택자가 필요하다는 것은 좋지 않습니다. 우리가 원하는 것은 HTML 구조 (이미지 수)에 의존하지 않는 일반적인 CSS 코드입니다.</p>\n\n<p>전체 이미지 수를 제공하는 <code>sibling-count()</code>와 유사하게, <code>sibling-index()</code>를 사용하여 컨테이너 내의 각 이미지의 인덱스를 제공합니다. 우리가 해야 할 일은 애니메이션 속성을 업데이트하고 각 이미지에 대해 다른 인덱스 값을 사용하여 지연을 포함하는 것입니다. 따라서 각 이미지에 대해 다른 지연이 발생합니다!</p>\n\n<pre><code class=\"language-css\">animation:\n  x var(--d) linear infinite\n  calc(-1*sibling-index()*var(--d)/sibling-count());\n</code></pre>\n\n<p>모든 것이 완벽합니다! 최종 코드는 다음과 같습니다.</p>\n\n<pre><code class=\"language-css\">.container {\n  --s: 100px; /* 이미지 크기 */\n  --d: 4s; /* 애니메이션 지속 시간 */\n  --n: 4; /* 표시되는 이미지 수 */\n\n  display: flex;\n  width: calc(var(--n) * var(--s));\n  overflow: hidden;\n}\nimg {\n  width: var(--s);\n  offset: shape(from calc(var(--s)/-2) 50%, hline by calc(sibling-count() * var(--s)));\n  animation: x var(--d) linear infinite calc(-1*sibling-index()*var(--d)/sibling-count());\n}\n@keyframes x {\n  to {offset-distance: 100%}\n}\n</code></pre>\n\n<p>하드코딩된 값이나 매직 넘버 없이 10줄 미만의 CSS만 있습니다!</p>\n\n<h3>반응형으로 만들기</h3>\n\n<p>이전 예에서는 표시하려는 이미지 수에 맞게 컨테이너의 너비를 고정했지만, 컨테이너 너비를 알 수 없는 반응형 동작은 어떻습니까? 컨테이너에서 한 번에 N개의 이미지만 표시하려고 합니다.</p>\n\n<p>만들 수 있는 관찰은 컨테이너 너비가 NxS보다 크면 이미지 사이에 공간이 생긴다는 것입니다. 이는 <code>shape()</code>로 정의된 선이 더 길어야 함을 의미합니다. 추가 공간을 포함해야 하기 때문입니다. 목표는 선의 새 길이를 찾는 것입니다.</p>\n\n<p>N개의 이미지를 한 번에 표시한다는 것은 컨테이너 너비를 다음과 같이 표현할 수 있음을 의미합니다.</p>\n\n<pre><code class=\"language-css\">width = N x (image_size + space_around_image)\n</code></pre>\n\n<p>이미지 크기와 N (<code>--s</code> 및 <code>--n</code>으로 정의됨)을 알고 있으므로 공간은 컨테이너 너비에 따라 달라집니다. 컨테이너가 클수록 공간이 더 많이 생깁니다. 이 공간은 선의 길이에 포함되어야 합니다.</p>\n\n<p>다음 대신:</p>\n\n<pre><code class=\"language-css\">hline by calc(sibling-count() * var(--s))\n</code></pre>\n\n<p>다음과 같이 사용해야 합니다.</p>\n\n<pre><code class=\"language-css\">hline by calc(sibling-count() * (var(--s) + space_around_image))\n</code></pre>\n\n<p>컨테이너 너비의 공식을 사용하고 (var(--s) + space_around_image)를 width / var(--n)으로 대체하여 다음을 얻습니다.</p>\n\n<pre><code class=\"language-css\">hline by calc(sibling-count() * width / var(--n) )\n</code></pre>\n\n<p>음, width 값은 어떻습니까? 알 수 없으므로 어떻게 찾을 수 있을까요?</p>\n\n<p>너비는 100%에 불과합니다! <code>offset</code>은 부모 컨테이너를 계산의 참조로 고려한다는 것을 기억하십시오. 따라서 100%는 부모 치수에 상대적입니다. 수평 선을 그리고 있으므로 100%는 컨테이너 너비로 해석됩니다.</p>\n\n<p>새로운 <code>offset</code> 값은 다음과 같습니다.</p>\n\n<pre><code class=\"language-css\">shape(from calc(var(--s)/-2) 50%, hline by calc(sibling-count() * 100% / var(--n)));\n</code></pre>\n\n<p>이제 애니메이션이 반응형입니다.</p>\n\n<p>아래 데모에서 컨테이너 (또는 화면) 크기를 조절하고 마법을 확인하세요.</p>\n\n<p>반응형 부분을 가지고 있지만 여전히 완벽하지는 않습니다. 컨테이너가 너무 작으면 이미지가 서로 겹쳐 보일 수 있기 때문입니다.</p>\n\n<p>새로운 코드와 이전 코드를 결합하여 이를 수정할 수 있습니다. 아이디어는 선의 길이가 최소한 이미지 하나 크기에 전체 이미지 수를 곱한 값과 같도록 하는 것입니다. 기억하세요. 이미지가 겹치지 않고 선 안에 모두 포함되도록 하는 것은 길이입니다.</p>\n\n<p>따라서 다음 부분을 업데이트합니다.</p>\n\n<pre><code class=\"language-css\">calc(sibling-count() * 100%/var(--n))\n</code></pre>\n\n<p>다음으로:</p>\n\n<pre><code class=\"language-css\">max(sibling-count() * 100%/var(--n), sibling-count() * var(--s))\n</code></pre>\n\n<p><code>max()</code>의 첫 번째 인수는 반응형 길이이고 두 번째 인수는 고정 길이입니다. 첫 번째 값이 두 번째 값보다 작으면 후자를 사용하고 이미지가 겹치지 않습니다.</p>\n\n<p>코드를 약간 더 최적화할 수 있습니다.</p>\n\n<pre><code class=\"language-css\">calc(sibling-count() * max(100%/var(--n),var(--s)))\n</code></pre>\n\n<p>이미지가 서로 닿지 않도록 하여 최소 간격 역할을 할 작은 양을 고정 길이에 추가할 수도 있습니다.</p>\n\n<pre><code class=\"language-css\">calc(sibling-count() * max(100%/var(--n),var(--s) + 10px))\n</code></pre>\n\n<p>완료되었습니다! 최신 CSS를 사용한 완전 반응형 마퀴 애니메이션입니다.</p>\n\n<p>기사 시작 부분에 공유했던 데모를 모든 조정을 거쳐 다시 보여드립니다.</p>\n\n<p>코드가 여전히 복잡해 보이나요? 나는 그렇지 않기를 바랍니다!</p>\n\n<p><code>min()</code> 또는 <code>max()</code>의 사용이 항상 직관적이지는 않지만, 어느 것을 사용해야 하는지 식별하는 데 도움이 되는 작은 튜토리얼이 있습니다.</p>\n\n<h3>더 많은 예제</h3>\n\n<p>이미지를 사용하여 기술을 설명했지만, 다른 종류의 콘텐츠로 쉽게 확장할 수 있습니다. 유일한 요구 사항/제한 사항은 동일한 너비의 항목을 갖는 것입니다.</p>\n\n<p>텍스트 애니메이션을 할 수 있습니다.</p>\n\n<p>또는 이미지 + 텍스트와 같은 더 복잡한 요소:</p>\n\n<p>두 예 모두 컨테이너가 작아질 때 flex 항목의 기본 축소 효과를 방지하기 위해 <code>flex-shrink: 0</code>을 사용하고 있습니다. 이미지의 경우 정의된 크기 이하로 축소되지 않기 때문에 이 문제가 발생하지 않았습니다.</p>\n\n<h3>결론</h3>\n\n<p>일부는 마퀴 애니메이션이 필요하지 않을 수 있지만, <code>shape()</code> 및 <code>sibling-*()</code> 함수와 같이 유용할 수 있는 최신 기능을 탐색하는 좋은 기회였습니다. <code>div</code> 변수, <code>calc()</code>, <code>max()</code> 등의 사용은 더 일반적이지만 여전히 최신 CSS의 일부로 간주됩니다.</p>\n```","createdAt":"2025-08-12T09:57:45.187Z","language":"ko"}