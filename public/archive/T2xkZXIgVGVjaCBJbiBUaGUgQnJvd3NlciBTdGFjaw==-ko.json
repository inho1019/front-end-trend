{"title":"Older Tech In The Browser Stack","content":"<body>\n<p>이 글은 웹 개발에서 현대적인 프레임워크에 가려져 잘 알려지지 않았지만 여전히 유용한 오래된 기술, 특히 XPath에 대해 다룹니다. 저자는 젊은 개발자들이 역사적 맥락 없이 새로운 프로그래밍 패러다임을 접하는 경향을 지적하며, 이는 과거의 기술을 이해하지 못하는 데서 비롯될 수 있다고 설명합니다.</p>\n<p>사례로, UI에서 사용자가 특정 탭을 떠나는지 감지하는 문제에 JavaScript의 <code>beforeunload</code>, <code>pageHide</code>, <code>visibilityChange</code> 이벤트를 언급하지만, 이는 과거부터 사용되어 온 기술입니다. 또한 React와 같은 프레임워크가 개발 경험을 향상시키지만, CSSOM과 같은 전통적인 개념에 대한 이해를 희석시킬 수 있다고 말합니다. 전자상거래 사이트의 React 프로젝트에서 특정 페이지에만 필요한 스타일시트 로딩 문제를 해결하는 과정에서 동적으로 스타일시트를 로드하는 방법을 모르는 개발자의 사례를 예로 듭니다.</p>\n<p>이러한 경험을 바탕으로 저자는 XSLT 프로그래밍이 브라우저에서 제거될 것이라는 WHATWG 논의를 언급하며, XML과 유사한 HTML과 같은 오래된 기술이 CSSOM과 같은 실용적인 문제 해결에 유용할 수 있다고 주장합니다. 특히 XPath를 XML 외부에서 활용하는 데 초점을 맞춥니다.</p>\n<h2>XPath: 핵심 API</h2>\n<p>XPath는 마크업 트리에서 노드나 속성을 찾는 쿼리 언어입니다. CSS 선택자가 페이지의 대부분 요소를 찾을 수 있지만, DOM 내에서의 현재 위치를 기준으로 요소를 찾지는 못하는 한계가 있습니다. XPath는 이러한 제약을 극복할 수 있습니다.</p>\n<p>저자는 XPath의 방대한 내용 때문에 본 글에서 모든 것을 다룰 수는 없으며, 기본적인 내용과 실제 활용 사례를 링크로 제공할 것을 약속합니다.</p>\n<h2>XPath & CSS 조합</h2>\n<p>XPath는 CSS 선택자가 할 수 없는 요소 검색을 수행할 수 있으며, CSS 선택자는 클래스 이름으로 요소를 쿼리하는 데 강점이 있습니다. 둘은 상호 보완적으로 사용될 수 있으며, XPath는 CSS보다 클래스 속성 문자열 비교에 있어 더 넓은 범위를 가집니다.</p>\n<p>JavaScript의 <code>document.evaluate</code>와 CSS API의 쿼리 선택자 메서드는 호환되지 않지만, 저자는 이를 해결하기 위한 호환 쿼리 API의 예시를 제시합니다. 이 API는 <code>queryCSSSelectors</code>와 <code>queryXPaths</code> 메서드를 제공합니다. (주의: 본 예시는 프로덕션 환경에서 사용하기 위한 것이 아닙니다.)</p>\n<h2>XPath 쿼리 예시</h2>\n<ul>\n<li><code>//li/text()</code>: 모든 <code>li</code> 요소의 텍스트 노드를 반환합니다.</li>\n<li><code>//a[text() = 'Sign In']/@href</code>: 텍스트가 \"Sign In\"인 <code>a</code> 요소의 <code>href</code> 속성 값을 반환합니다.</li>\n</ul>\n<h2>XPath 함수 개요</h2>\n<p>주요 XPath 함수는 다음과 같습니다.</p>\n<ul>\n<li><code>starts-with(string, prefix)</code>: 문자열이 특정 접두사로 시작하는지 확인합니다.</li>\n<li><code>contains(string, substring)</code>: 문자열에 특정 부분 문자열이 포함되어 있는지 확인합니다.</li>\n<li><code>count(nodeset)</code>: 노드 집합의 개수를 반환합니다.</li>\n<li><code>substring(string, start, length)</code>: 문자열의 일부를 추출합니다.</li>\n<li><code>substring-before(string, separator)</code>: 구분자 이전의 문자열 부분을 반환합니다.</li>\n<li><code>substring-after(string, separator)</code>: 구분자 이후의 문자열 부분을 반환합니다.</li>\n<li><code>normalize-space(string)</code>: 문자열의 공백을 정규화합니다.</li>\n<li><code>not(boolean)</code>: 불리언 값을 반전시킵니다.</li>\n<li><code>true()</code>, <code>false()</code>: 불리언 값 true 또는 false를 반환합니다.</li>\n<li><code>concat(string1, string2, ...)</code>: 여러 문자열을 연결합니다.</li>\n<li><code>string-length(string)</code>: 문자열의 길이를 반환합니다.</li>\n<li><code>translate(string, from, to)</code>: 문자열 내에서 문자를 다른 문자로 변환합니다. (주의: <code>from</code>에 있으나 <code>to</code>에 없는 문자는 제거됩니다.)</li>\n</ul>\n<p>이 외에도 <code>floor</code>, <code>ceiling</code>, <code>round</code>, <code>sum</code> 등 JavaScript와 유사한 수치 함수와 <code>boolean</code>, <code>number</code>, <code>string</code>, <code>node</code>와 같은 타입 변환 함수가 있습니다.</p>\n<h2>XPath translate 함수 활용</h2>\n<p>XPath의 <code>translate</code> 함수는 JavaScript의 <code>replaceAll</code>보다 강력할 수 있으며, 대소문자를 구분한 변환이나 특정 문자 제거 등에 유용합니다. 예를 들어, 카이사르 암호 구현이나 움라우트 문자 변환 등에 활용될 수 있습니다.</p>\n<h2>CSS와 XPath 함께 사용하기</h2>\n<p>클래스 이름으로 요소를 찾는 데 CSS 선택자가 유리하지만, XPath는 클래스 속성 문자열 비교를 통해 더 넓은 범위를 다룰 수 있습니다. 그러나 `.primaryLinks`와 `.primaryLinks2`와 같이 유사한 클래스 이름이 있을 경우 문제가 발생할 수 있습니다.</p>\n<p>저자는 CSS 선택자를 사용하여 컨텍스트 노드를 설정한 후, 해당 컨텍스트 노드에서 XPath를 사용하여 복잡한 쿼리를 수행하는 데모를 보여줍니다. 특히 <code>//</code>(전체 문서 검색)과 <code>.</code>(현재 노드 검색)의 차이, 그리고 <code>normalize-space</code> 함수를 사용한 텍스트 노드 공백 제거 예시를 설명합니다.</p>\n<h2>XPath 함수 예시</h2>\n<ul>\n<li><code>substring-after(//a/@href,'https://')</code>: 여러 <code>href</code> 속성에서 추출된 첫 번째 결과만 반환하는 문제점을 지적합니다.</li>\n<li><code>document.queryCSSSelectors(\"a\").queryXPaths(\"substring-after(./@href,'https://')\")</code>: CSS 선택자와 XPath를 조합하여 여러 <code>href</code> 속성에서 원하는 부분을 추출하는 방법을 보여줍니다.</li>\n<li>XPath 함수는 중첩될 수 있으며, 복잡한 URL 파싱 등에 활용될 수 있습니다.</li>\n</ul>\n<h2>XPath 추가 활용 사례</h2>\n<p>XPath는 테스트 자동화에서 특히 유용합니다. CSS 선택자는 빌드 시스템 변경 등에 취약할 수 있지만, XPath는 요소의 텍스트 내용 등을 기반으로 더 견고한 매치를 할 수 있습니다. 또한, DOM 구조에 관계없이 원하는 요소를 정확하게 식별하는 데 강력한 기능을 제공합니다.</p>\n<p>복잡한 DOM 구조에서 특정 요소를 찾는 예시로, 특정 <code>div</code> 바로 다음에 오는 <code>div</code>의 <code>img</code> 태그에 `data-testID=\"leader\"` 속성이 있는 경우, 그 <code>div</code>의 <code>h2</code> 태그 텍스트를 가져오는 XPath 쿼리를 제시합니다.</p>\n<h2>XSLT 1.0 지원 중단</h2>\n<p>Chrome 팀이 XSLT 1.0 지원을 중단할 예정이지만, 이는 XPath 1.0에도 영향을 줄 수 있습니다. 하지만 XPath 자체는 테스트 등에서 여전히 유용할 것이므로 곧 사라지지는 않을 것으로 예상됩니다.</p>\n<p>XSLT 1.0 중단에 대한 논의와 함께, JavaScript를 Shim으로 사용하거나 SaxonJS와 같은 솔루션을 브라우저에 통합하는 아이디어가 언급됩니다. SaxonJS 개발사인 Saxonica의 관계자는 브라우저 벤더들이 SaxonJS를 통합하는 데 관심을 보인다면 논의할 의향이 있다고 밝혔습니다.</p>\n<h2>결론</h2>\n<p>XPath는 현대 웹 개발 환경에서 간과되기 쉽지만, 여전히 강력하고 유용한 기술입니다. 저자는 이 글을 통해 XPath의 유용성을 강조하고, 개발자들이 이 오래된 기술을 새롭게 인식하고 활용할 수 있도록 돕고자 합니다.</p>\n<h2>추가 자료</h2>\n<ul>\n<li>\"Enhancing the Resiliency of Automated Web Tests with Natural Language\": resilient 테스트 작성을 위한 XPath 예시를 제공합니다.</li>\n<li>XPath (MDN): XPath의 기술적인 설명을 제공합니다.</li>\n<li>XPath Tutorial (ZVON): 풍부한 예시와 명확한 설명으로 XPath 학습에 도움이 됩니다.</li>\n<li>XPather: XPath 코드를 직접 테스트해볼 수 있는 인터랙티브 도구입니다.</li>\n</ul>\n</body>","createdAt":"2025-11-13T08:00:00.000+00:00","link":"https://smashingmagazine.com/2025/11/older-tech-browser-stack/","language":"ko"}