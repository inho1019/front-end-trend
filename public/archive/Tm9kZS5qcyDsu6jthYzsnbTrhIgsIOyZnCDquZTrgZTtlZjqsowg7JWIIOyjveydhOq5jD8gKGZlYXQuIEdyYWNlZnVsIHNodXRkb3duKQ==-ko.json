{"title":"Node.js 컨테이너, 왜 깔끔하게 안 죽을까? (feat. Graceful shutdown)","content":"<body>\n    <h2>Graceful Shutdown: Node.js 컨테이너 환경에서의 문제 해결</h2>\n    \n    <h3>1. 배경</h3>\n    <ul>\n        <li>배치 컨슈머 앱 운영 중, 종료 시그널을 보냈음에도 불구하고 일부 작업이 반영되지 않거나 프로세스가 강제 종료되는 문제 발생.</li>\n        <li>단순 시그널 처리 문제가 아닌, Linux 커널의 PID 1 보호 메커니즘과 Node.js 이벤트 루프 동작 방식이 복합적으로 작용한 결과임을 파악.</li>\n        <li>Kubernetes 환경에서의 graceful shutdown의 의미와 프로세스 종료 과정에 대한 깊은 이해 필요성을 느낌.</li>\n    </ul>\n\n    <h3>2. 문제 원인 분석 및 해결 방안</h3>\n    <h4>2.1. 앱이 시그널을 무시하는 문제</h4>\n    <ul>\n        <li><strong>원인:</strong> Linux 커널은 PID 1 프로세스(init 프로세스)를 특별하게 보호하여, 시그널 핸들러가 없을 경우 시그널을 무시하는 'Global init gets no signals it doesn’t want' 원칙 적용. Node.js가 PID 1 역할을 할 때 발생하는 문제.</li>\n        <li><strong>해결:</strong></li>\n        <ul>\n            <li><strong>dumb-init 도입:</strong> 컨테이너 환경에서 PID 1 역할을 하며 시그널 전파 및 좀비 프로세스 정리를 담당하는 init 시스템 사용.</li>\n            <li><strong>Dockerfile 예시:</strong>\n                <pre>\n                    <code>\n                        # Dockerfile - dumb-init을 PID 1로 설정하여 시그널 전달 보장\n                        RUN apt-get update && apt-get install -y dumb-init\n\n                        ENTRYPOINT [\"/usr/bin/dumb-init\", \"--\"]\n                        CMD [\"node\", \"dist/main\"]\n                    </code>\n                </pre>\n            </li>\n        </ul>\n    </ul>\n\n    <h4>2.2. 2분 타임아웃 설정에도 5분 동안 종료되지 않는 문제</h4>\n    <ul>\n        <li><strong>원인:</strong> Promise.race에서 타임아웃이 먼저 완료되어도, 취소되지 않은 비동기 작업(예: await sleep)이 이벤트 루프에 남아 있어 Node.js가 종료를 미루기 때문. 함수가 종료된다고 해서 프로세스가 바로 종료되는 것이 아님.</li>\n        <li><strong>해결:</strong></li>\n        <ul>\n            <li><strong>AbortController 도입 검토:</strong> 백그라운드 작업을 강제로 중단하기 위해 AbortController 사용을 고려했으나, 코드 복잡도 증가 및 외부 라이브러리 중단 처리의 불확실성, 데이터 정합성 문제로 인해 채택하지 않음.</li>\n            <li><strong>최종 버전:</strong></li>\n            <ul>\n                <li><strong>애플리케이션 레벨:</strong> 셧다운 훅(onModuleDestroy)에서 Promise.race를 사용하여 앱 타임아웃(2분) 설정.</li>\n                <li><strong>인프라 레벨:</strong> Kubernetes의 terminationGracePeriodSeconds를 앱 타임아웃보다 길게(3분) 설정하여, 앱 종료 후에도 Kubernetes에서 추가적인 종료 시간을 보장하도록 함.</li>\n            </ul>\n        </ul>\n    </ul>\n\n    <h3>3. 핵심 요약</h3>\n    <ul>\n        <li><strong>Init 프로세스 사용:</strong> dumb-init 또는 tini와 같은 init 시스템을 사용하여 시그널 전달 및 좀비 프로세스 방지.</li>\n        <li><strong>Node 직접 실행:</strong> 'npm start' 대신 'node dist/main'으로 직접 실행하여 시그널 전달 방해 방지.</li>\n        <li><strong>이벤트 루프 이해:</strong> Promise.race의 타임아웃이 완료되어도, 비동기 작업이 이벤트 루프에 남아 있으면 프로세스는 종료되지 않음.</li>\n        <li><strong>설정 동기화:</strong> 애플리케이션의 종료 타임아웃 설정과 Kubernetes의 terminationGracePeriodSeconds를 상호 보완적으로 설정.</li>\n    </ul>\n\n    <h3>4. 결론</h3>\n    <ul>\n        <li>Graceful Shutdown의 핵심은 단순히 종료 훅을 추가하는 것을 넘어, 종료 시점에 이벤트 루프에 어떤 작업이 남아 있는지 이해하고 제어하는 것.</li>\n        <li>Node.js 이벤트 루프, PID 1 프로세스, Kubernetes 종료 정책 등 기술적 요소들이 맞물려 동작함을 인지하고, 각 요소의 책임을 분담하는 것이 중요.</li>\n        <li>문제의 배경과 해결하고자 하는 목표를 명확히 파악하여 오버엔지니어링을 피하고 현실적인 해결책을 선택하는 것이 필요.</li>\n    </ul>\n</body>","createdAt":"2026-01-19T15:00:00.000+00:00","link":"https://tech.socarcorp.kr/dev/2026/01/19/nodejs-graceful-shutdown.html","language":"ko"}