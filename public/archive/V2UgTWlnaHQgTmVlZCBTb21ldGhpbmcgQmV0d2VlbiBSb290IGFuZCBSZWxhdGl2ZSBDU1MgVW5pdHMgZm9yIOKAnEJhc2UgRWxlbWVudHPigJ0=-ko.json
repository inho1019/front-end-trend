{"content":"<body>\n  <p>CSS는 루트(root) 값과 상대(relative) 값이라는 두 가지 단위를 제공합니다. 루트 값(예: <code>rem</code>, <code>rlh</code>)은 <code>:root</code> 선택자에 정의된 값을 따르는 반면, 상대 값(예: <code>em</code>, <code>lh</code>, <code>ch</code>)은 해당 요소의 <code>font-size</code>에 영향을 받습니다.</p>\n      \n  <p>이 글에서는 루트 값과 상대 값 사이에 새로운 단위의 필요성을 제안합니다. 이 중간 단위는 복잡한 계산 없이 요소의 크기를 조정할 수 있게 해줍니다.</p>\n\n  <h2>예시: Prose와 Card 컴포넌트</h2>\n  \n  <h3>Prose 예시</h3>\n  <ul>\n    <li><code>lh</code> 단위를 사용하여 <code>margin</code>과 <code>padding</code>에 타이포그래피의 수직 리듬을 적용할 수 있습니다.</li>\n    <li><code>* + *</code> 또는 <code>*:not(:first-child)</code> 선택자를 사용하여 형제 요소 간의 간격을 <code>1lh</code>로 설정할 수 있습니다.</li>\n    <li><code>.prose</code> 클래스를 사용하여 선택자를 특정 영역으로 제한할 수 있습니다.</li>\n    <li>다른 폰트 크기를 가진 타이포그래피가 혼합될 경우, <code>1lh</code>의 크기 변화로 인해 레이아웃이 깨질 수 있습니다.</li>\n    <li>Flexbox의 <code>gap</code> 속성을 <code>1lh</code>로 설정하면 이 문제를 해결할 수 있습니다.</li>\n    <li>하지만 Flexbox 사용 시, 관련 없는 콘텐츠 간의 구분을 위해 간격을 다르게 설정해야 할 필요가 생기며, 이때 <code>lh</code>를 사용한 <code>margin</code> 설정이 어려워집니다.</li>\n  </ul>\n\n  <h3>Card 컴포넌트 예시</h3>\n  <ul>\n    <li>Card 컴포넌트에서 제목과 본문의 폰트 크기가 다를 경우, <code>lh</code> 단위를 사용하여 내부 <code>padding</code>을 설정하면 제목의 <code>margin</code>이 과도하게 커지는 문제가 발생합니다.</li>\n    <li>이 문제를 해결하기 위해 <code>header</code>를 별도 <code>div</code>로 감싸거나, <code>rlh</code>와 같은 루트 값을 사용할 수 있습니다.</li>\n    <li>하지만 <code>.card</code> 자체의 폰트 크기가 변경될 경우, <code>rlh</code> 값도 비례적으로 커져 적절하지 않게 보일 수 있습니다.</li>\n    <li>이러한 문제를 해결하기 위해 여러 크기 변형에 따라 <code>padding</code> 값을 하드코딩하는 방법이 있지만, 이는 유연하지 않습니다.</li>\n  </ul>\n\n  <h2>새로운 중간 단위 제안: Base Unit (<code>bem</code>, <code>blh</code>)</h2>\n  \n  <p>루트 값과 상대 값 사이의 중간 단위를 통해 이러한 문제를 해결할 수 있습니다. 이 단위는 특정 요소(예: <code>.card</code>)를 기준으로 <code>font-size</code> 또는 <code>line-height</code>를 참조합니다. 예를 들어, <code>1bem</code>은 지정된 요소의 <code>1em</code>과 같고, <code>1blh</code>는 지정된 요소의 <code>1lh</code>와 같습니다.</p>\n\n  <ul>\n    <li>이러한 <code>base unit</code>은 <code>container queries</code> 또는 <code>anchor positioning</code>과 같은 메커니즘을 통해 구현될 수 있습니다.</li>\n    <li><code>container queries</code> 방식은 <code>container-type</code> 설정이 필요하며, 중첩된 컨테이너에서 참조 충돌이 발생할 수 있습니다.</li>\n    <li><code>anchor positioning</code> 방식은 <code>base-anchor</code> 속성을 사용하여 참조할 기반 요소를 명시적으로 지정하며, 다른 컴포넌트에서도 <code>base-name</code>을 통해 참조할 수 있어 유연성이 높습니다.</li>\n    <li><code>double anchor</code> 기능을 통해 한 컴포넌트가 다른 컴포넌트의 폰트 크기나 값을 상속받아, 다양한 컴포넌트 변형을 쉽게 만들 수 있습니다.</li>\n  </ul>\n\n  <h2>현재 CSS로 구현하는 방법</h2>\n  \n  <p>현재 CSS에서는 <code>--base-size</code>와 <code>calc()</code> 함수를 사용하여 <code>bem</code>과 유사한 기능을 구현할 수 있습니다. 하지만 이는 단위 처리가 복잡하고, Sass 믹스인이나 Tailwind CSS 유틸리티를 사용하면 코드를 더 간결하게 만들 수 있습니다.</p>\n\n  <p>CSS 함수가 지원되면 <code>--bem()</code>과 <code>--blh()</code>와 같은 함수를 사용하여 더 직관적으로 구현할 수 있습니다. Splendid Labz의 <code>@splendidlabz/styles</code> 라이브러리를 통해 현재 구현 가능한 방법을 활용할 수 있습니다.</p>\n\n  <p>작성자는 이러한 중간 단위를 \"base unit\"이라고 부르는 것에 대한 의견을 묻고 있으며, <code>bem</code>과 <code>blh</code>라는 이름에 대한 타당성과 더 나은 대안이 있는지 독자들에게 질문합니다.</p>\n</body>","createdAt":"2025-08-13T19:27:54.894Z","language":"ko"}