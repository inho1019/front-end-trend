{"content":"<body>\n  <h2>React.memo, useMemo, useCallback 최적화 함정과 올바른 접근법</h2>\n  <p>이 글은 React.memo, useMemo, useCallback의 실제 동작 원리와 흔히 발생하는 최적화 함정을 코드 예제와 함께 분석합니다. 많은 개발자가 메모이제이션으로 리렌더링을 막을 수 있다고 오해하지만, 자바스크립트의 참조 비교 특성상 props 스프레드, JSX children, 중첩된 memo 컴포넌트 등 흔한 패턴으로 최적화가 무력화될 수 있습니다. React의 기본 규칙인 부모 리렌더링 시 자식도 리렌더링되는 점을 시작으로, 언제 메모이제이션이 효과적인지 명확히 설명합니다.</p>\n  <p>메모이제이션보다 우선해야 할 접근법으로 컴포넌트 합성을 통한 상태 분리 및 렌더링 경계 재설계를 제시합니다. 권장 순서는 React DevTools Profiler로 병목을 측정하고, 구조적 개선을 시도한 뒤, 필요한 곳에만 메모이제이션을 적용하는 것입니다. 팀이 \"일단 memo부터\" 접근한다면 이 글이 최적화 전략 재검토의 계기가 될 것입니다.</p>\n  <h3>주요 내용</h3>\n  <ul>\n    <li>메모이제이션의 약속과 문제 이해: 자바스크립트 참조 비교</li>\n    <li>useMemo와 useCallback 내부 동작 원리</li>\n    <li>흔한 오해: 프로퍼티 메모이제이션</li>\n    <li>React.memo 실제 동작 및 숨겨진 함정: 프로퍼티 스프레드, children, 중첩된 memo</li>\n    <li>메모이제이션 사용 시점: React.memo, useMemo, useCallback</li>\n    <li>대안: 합성(Composition)</li>\n  </ul>\n</body>","createdAt":"2025-08-14T04:47:13.524Z","language":"ko"}